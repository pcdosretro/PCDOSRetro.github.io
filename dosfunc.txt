INT 20 Program terminate (1.0+)
Entry: CS=PSP
Exit:  Does not return to caller

INT 21 Execute DOS function
00 Program terminate (1.0+)
   Entry: CS=PSP
   Exit:  Does not return to caller
01 Character input (1.0+)
   Entry: None
   Exit:  AL=character
02 Character output (1.0+)
   Entry: DL=character
   Exit:  None
03 Auxiliary input (1.0+)
   Entry: None
   Exit:  AL=character
04 Auxiliary output (1.0+)
   Entry: DL=character
   Exit:  None
05 Printer output (1.0+)
   Entry: DL=character
   Exit:  None
06 Direct console I/O (1.0+)
   Entry: DL=FF for console input
          DL=character for console output
   Exit:  ZF=0 if a character is ready, AL=character
          ZF=1 if no character is ready
07 Direct console input without echo (1.0+)
   Entry: None
   Exit:  AL=character
08 Console input without echo (1.0+)
   Entry: None
   Exit:  AL=character
09 Display string (1.0+)
   Entry: DS:DX->string ending with $
   Exit:  None
0A Buffered keyboard input (1.0+)
   Entry: DS:DX->input buffer (first byte of buffer=maximum input length)
   Exit:  second byte of buffer=actual input length
0B Get input status (1.0+)
   Entry: None
   Exit:  AL=00 no character available
          AL=FF character available
0C Flush input buffer and input (1.0+)
   Entry: AL=function number (01,06,07,08,or 0A otherwise flush only)
          DS:DX->input buffer if function 0A
   Exit:  AL=character unless function 0A
0D Disk reset (1.0+)
   Entry: None
   Exit:  None
0E Set default drive (1.0+)
   Entry: DL=drive code (0=A)
   Exit:  AL=number of logical drives
0F Open file (1.0+)
   Entry: DS:DX->unopened FCB
   Exit:  AL=00 file opened
          AL=FF file not found
10 Close file (1.0+)
   Entry: DS:DX->opened FCB
   Exit:  AL=00 file closed
          AL=FF file not found
11 Find first file (1.0+)
   Entry: DS:DX->unopened FCB
   Exit:  AL=00 matching filename found
                buffer at DTA receives an unopened FCB and directory entry
                original FCB contents:
                FCB    search drive code (1=A)
                FCB+1  specified filespec
                FCB+12 search attribute byte
                FCB+13 directory entry offset
                FCB+15 directory cluster (0=root)
                FCB+17 unused
                FCB+21 actual drive code (1=A)
          AL=FF matching filename not found
   Note:  The file's directory entry is returned after the FCB drive code.
          If a character device is found then the directory attribute byte
          is set to 40h.
12 Find next file (1.0+)
   Entry: DS:DX->unopened FCB from previous 11 or 12 call
   Exit:  AL=00 matching filename found
                buffer at DTA receives an unopened FCB and directory entry
          AL=FF matching filename not found
   Note:  The file's directory entry is returned after the FCB drive code.
13 Delete file (1.0+)
   Entry: DS:DX->unopened FCB
   Exit:  AL=00 file deleted
          AL=FF matching filename not found or files are read-only
14 Sequential read (1.0+)
   Entry: DS:DX->opened FCB
   Exit:  AL=00 file was read
          AL=01 EOF (no data read)
          AL=02 segment wrap
          AL=03 EOF (partial read)
15 Sequential write (1.0+)
   Entry: DS:DX->opened FCB
   Exit:  AL=00 file was written
          AL=01 disk full
          AL=02 segment wrap
16 Create or truncate file (1.0+)
   Entry: DS:DX->unopened FCB
   Exit:  AL=00 file created
          AL=FF directory full
17 Rename file (1.0+)
   Entry: DS:DX->rename FCB (FCB+11h->new filename)
   Exit:  AL=00 file renamed
          AL=FF no matching files found or new filename already exists
18 Reserved
19 Get default drive (1.0+)
   Entry: None
   Exit:  AL=drive code (0=A)
1A Set disk transfer address (1.0+)
   Entry: DS:DX=new DTA
   Exit:  None
1B Get allocation info for default drive (1.0+)
   Entry: None
   Exit:  AL=sectors per cluster
          CX=bytes per sector
          DX=clusters per drive
          DS:BX->media descriptor byte
          AL=FF invalid drive
1C Get allocation info for specified drive (1.1+)
   Entry: DL=drive code (0=default)
   Exit:  Same as function 1B
1D Reserved
1E Reserved
1F Get disk parameter block for default drive (1.1+)
   Entry: None
   Exit:  AL=00 drive valid
          DS:BX->disk parameter block
             0 drive code (0=A)             13 maximum cluster number
             1 unit code                    15 sectors per FAT
             2 bytes per sector             17 first directory sector
             4 sectors per cluster-1        19 pointer to device driver
             5 cluster shift factor         23 media descriptor byte
             6 first FAT sector             24 access flag (0=accessed)
             8 number of FATs               25 pointer to next DPB
             9 number of directory entries  29 last cluster allocated
            11 first data sector            31 free clusters (-1=unknown)
          AL=FF drive invalid
   Note:  (3.x) The sectors per FAT field is one byte and all following
          fields are moved back one byte.
20 Reserved
21 Random read (1.0+)
   Entry: DS:DX->opened FCB
   Exit:  AL=00 file was read
          AL=01 EOF (no data read)
          AL=02 segment wrap
          AL=03 EOF (partial read)
22 Random write (1.0+)
   Entry: DS:DX->opened FCB
   Exit:  AL=00 file was written
          AL=01 disk full
          AL=02 segment wrap
23 Get file size in records (1.0+)
   Entry: DS:DX->unopened FCB
   Exit:  AL=00 random record field is set by dividing the file size by the
                specified record size
          AL=FF file not found
24 Set random record number (1.0+)
   Entry: DS:DX->opened FCB
   Exit:  random record field is set based on record size, current record,
          and current block
25 Set interrupt vector (1.0+)
   Entry: DS:DX=new address
          AL=interrupt number
   Exit:  None
26 Create PSP (1.0+)
   Entry: CS=PSP
          DX=segment for new PSP
   Exit:  None
27 Random block read (1.0+)
   Entry: DS:DX->opened FCB
          CX=number of records to read
   Exit:  AL=00 file was read
          AL=01 EOF (no data read)
          AL=02 segment wrap
          AL=03 EOF (partial read)
          CX=actual number of records read
28 Random block write (1.0+)
   Entry: DS:DX->opened FCB
          CX=number of records to write
   Exit:  AL=00 file was written
          AL=01 disk full
          AL=02 segment wrap
          CX=actual number of records written
29 Parse filename (1.0+)
   Entry: DS:SI->string to parse
          ES:DI->buffer for unopened FCB
          AL=flags
             Bit 0 1=ignore leading separators
                 1 1=modify FCB drive code byte only if a drive is specified
                 2 1=modify FCB filename only if a filename is specified
                 3 1=modify FCB extension only if an extension is specified
   Exit:  DS:SI->first character after parsed filename
          AL=00 no wildcard characters in string
          AL=01 wildcard characters in string
          AL=FF invalid drive
2A Get date (1.0+)
   Entry: None
   Exit:  AL=weekday (0=Sunday)
          CX=year
          DH=month
          DL=day
2B Set date (1.0+)
   Entry: CX=year
          DH=month
          DL=day
   Exit:  AL=00 date set
          AL=FF invalid date
2C Get time (1.0+)
   Entry: None
   Exit:  CH=hours
          CL=minutes
          DH=seconds
          DL=hundredths
2D Set time (1.0+)
   Entry: CH=hours
          CL=minutes
          DH=seconds
          DL=hundredths
   Exit:  AL=00 time set
          AL=FF invalid time
2E Set verify flag (1.1+)
   Entry: AL=verify flag (0=off,1=on)
   Exit:  None
2F Get disk transfer address (2.0+)
   Entry: None
   Exit:  ES:BX=DTA
30 Get DOS version (2.0+)
   Entry: AL=0 return OEM number (5.0+)
          AL=1 return version flag (5.0+)
   Exit:  AL=major version number
          AH=minor version number
          BH=OEM number or version flag (00=RAM,08=ROM)
          BL:CX=24-bit serial number or 0
31 Terminate and stay resident (2.0+)
   Entry: AL=return code
          DX=memory size in paragraphs (minimum 6)
   Exit:  Does not return to caller
32 Get disk parameter block for specified drive (2.0+)
   Entry: DL=drive code (0=default)
   Exit:  Same as function 1F
33 Get or set Ctrl-Break (2.0+)
   Entry: AL=0 get break
          AL=1 set break
          AL=2 swap break (*) (3.1+)
          AL=5 get boot drive (4.0+)
          AL=6 get DOS version (5.0+)
          DL=break flag if set or swap (0=off,1=on)
   Exit:  if function 00 or 02:
             DL=break flag
          if function 05:
             DL=boot drive code (1=A)
          if function 06:
             BL=major version
             BH=minor version
             DL=revision (0=A)
             DH=version flag (00=low,08=ROM,10=HMA)
34 Get InDOS flag pointer (2.0+)
   Entry: None
   Exit:  ES:BX->InDOS flag
   Note:  The DOS critical error flag immediately precedes this byte.
35 Get interrupt vector (2.0+)
   Entry: AL=interrupt number
   Exit:  ES:BX=interrupt address
36 Get free disk space (2.0+)
   Entry: DL=drive code (0=default)
   Exit:  AX=sectors per cluster
          BX=free clusters
          CX=bytes per sector
          DX=clusters per drive
          AX=FFFF if drive invalid
37 Get or set switch character (*) (2.0+)
   Entry: AL=0 get switch character
          AL=1 set switch character
          DL=switch character if set
   Exit:  DL=switch character if get
   Note:  (5.0+) Function 3701 has been disabled.
38 Get or set country info (2.0+)
   Entry: AL=country code (0=default)
          BX=country code if AL=FF (3.0+)
          DX=FFFF if set request (2.11+)
          DS:DX->buffer if get request
   Exit:  CF=0 BX=country code if get request (3.0+)
               buffer format:
                0 date format (0=USA,1=Europe,2=Japan)
                2 currency symbol string
                7 thousands separator
                9 decimal separator
               11 date separator
               13 time separator
               15 currency format
                  0 symbol before amount, no space between
                  1 symbol after amount, no space between
                  2 symbol before amount, 1 space between
                  3 symbol after amount, 1 space between
                  4 symbol replaces decimal separator
               16 digits after decimal in currency
               17 time format (0=12-hour,1=24-hour)
               18 case map call address
               22 data list separator
               24 reserved (10 bytes)
          CF=1 AX=error code
39 Create directory (2.0+)
   Entry: DS:DX->directory name
   Exit:  CF=0 None
          CF=1 AX=error code
3A Remove directory (2.0+)
   Entry: DS:DX->directory name
   Exit:  CF=0 None
          CF=1 AX=error code
3B Change current directory (2.0+)
   Entry: DS:DX->directory name
   Exit:  CF=0 None
          CF=1 AX=error code
3C Create or truncate file (2.0+)
   Entry: DS:DX->filename
          CX=file attributes
   Exit:  CF=0 AX=file handle
          CF=1 AX=error code
3D Open file (2.0+)
   Entry: DS:DX->filename
          AL=open mode
             Bit 0-2 access mode
                     000=read
                     001=write
                     010=read/write
                 4-6 sharing mode (3.0+)
                     000=compatibility
                     001=deny read/write access
                     010=deny write access
                     011=deny read access
                     100=deny none access
                   7 inheritance flag
                     0=file inherited by EXECed programs
                     1=file not inherited by EXECed programs
   Exit:  CF=0 AX=file handle
          CF=1 AX=error code
3E Close file (2.0+)
   Entry: BX=file handle
   Exit:  CF=0 None
          CF=1 AX=error code
3F Read file or device (2.0+)
   Entry: BX=file handle
          CX=bytes to read
          DS:DX->input buffer
   Exit:  CF=0 AX=number of bytes read (0=EOF)
          CF=1 AX=error code
40 Write file or device (2.0+)
   Entry: BX=file handle
          CX=bytes to write (0=truncate file)
          DS:DX->output buffer
   Exit:  CF=0 AX=number of bytes written (0=disk full)
          CF=1 AX=error code
41 Delete file (2.0+)
   Entry: DS:DX->filename
   Exit:  CF=0 None
          CF=1 AX=error code
42 Move file pointer (2.0+)
   Entry: AL=code (0=absolute,1=relative,2=relative to EOF)
          BX=file handle
          CX:DX=offset
   Exit:  CF=0 DX:AX=new pointer
          CF=1 AX=error code
43 Get or set file attributes (2.0+)
   Entry: AL=0 get attributes
          AL=1 set attributes
          CX=file attributes if set
             Bit 0 1=read-only
                 1 1=hidden
                 2 1=system
                 4 1=directory (get only)
                 5 1=archive
          DS:DX->filename
   Exit:  CF=0 CX=file attributes if get
          CF=1 AX=error code
44 I/O control for devices (2.0+)
   Notes: 1) Functions 02-05 work only if bit 14 of the device driver
             attribute word is set.
          2) Function 08 works only if bit 11 of the device driver
             attribute word is set.
          3) Functions 0C-0F work only if bit 6 of the device driver
             attribute word is set.
          4) Functions 10-11 work only if bit 7 of the device driver
             attribute word is set.
   00 Get device attributes (2.0+)
      Entry: BX=file handle
      Exit:  CF=0 DX=device attributes
                  Character devices:
                  Bit 0 1=console input
                      1 1=console output
                      2 1=NUL device
                      3 1=CLOCK device
                      4 1=INT 29 output (CON)
                      5 0=ASCII,1=binary
                      6 0=EOF on input
                      7 1=character device
                     11 1=open/close supported
                     13 1=output until busy supported
                     14 1=IOCTL supported
                  Block devices:
                  Bit 0-5 drive code (0=A)
                        6 0=file has been written
                        7 0=block device
             CF=1 AX=error code
   01 Set device attributes (2.0+)
      Entry: BX=file handle (character devices only)
             DX=device attributes (DH must be 0)
      Exit:  CF=0 None
             CF=1 AX=error code
   02 Read from character device (2.0+)
   03 Write to character device (2.0+)
      Entry: BX=file handle
             CX=number of bytes
             DS:DX->buffer
      Exit:  CF=0 AX=number of bytes transferred
             CF=1 AX=error code
   04 Read from block device (2.0+)
   05 Write to block device (2.0+)
      Entry: BL=drive code (0=default)
             CX=number of bytes
             DS:DX->buffer
      Exit:  CF=0 AX=number of bytes transferred
             CF=1 AX=error code
   06 Get input status (2.0+)
   07 Get output status (2.0+)
      Entry: BX=file handle
      Exit:  CF=0 AL=status (00=not ready,FF=ready)
             CF=1 AX=error code
   08 Removable media check (3.0+)
      Entry: BL=drive code (0=default)
      Exit:  CF=0 AX=value (0=removable,1=fixed)
             CF=1 AX=error code
   09 Local/remote drive check (3.0+)
      Entry: BL=drive code (0=default)
      Exit:  CF=0 DX=device attributes
                  Bit 1 1=32-bit sectors supported
                      6 1=generic IOCTL calls supported
                      7 1=query IOCTL call supported
                      9 1=shared drive; direct I/O not allowed
                     11 1=removable media call supported
                     12 1=remote drive
                     13 1=media descriptor in FAT required
                     14 1=IOCTL calls supported
                     15 1=SUBSTed
             CF=1 AX=error code
   0A Local/remote handle check (3.0+)
      Entry: BX=file handle
      Exit:  CF=0 DX=device attributes from SFT
                  Character devices:
                  Bit 0 1=console input
                      1 1=console output
                      2 1=NUL device
                      3 1=CLOCK device
                      4 1=INT 29 output (CON)
                      5 0=ASCII,1=binary
                      6 0=EOF on input
                      7 1=character device
                     11 1=network spooler
                     12 1=no inherit
                     13 1=named pipe
                     15 1=remote
                  Block devices:
                  Bit 0-5 drive code (0=A)
                        6 0=file has been written
                        7 0=block device
                       12 1=no inherit
                       14 1=date/time set
                       15 1=remote
             CF=1 AX=error code
   0B Change sharing retry count (3.0+)
      Entry: CX=delay loop count
             DX=retry count
      Exit:  None
   0C Generic IOCTL for handles (3.2+)
      Entry: BX=file handle
             CH=category code (01=AUX,03=CON,05=PRN)
             CL=function code
                45 set printer retry count
                4A set code page (3.3+)
                4C prepare start (3.3+)
                4D prepare end (3.3+)
                5F set display info (4.0+)
                65 get printer retry count
                6A get code page (3.3+)
                6B get prepare list (3.3+)
                7F get display info (4.0+)
             DS:DX->parameter block or retry count word
      Exit:  CF=0 None
             CF=1 AX=error code
      Get/set code page and prepare end parameter block format:
         0 length (2)
         2 code page
      Prepare start parameter block format:
         0 flags (device specific)
         2 data length
         4 number of code pages
         6 code pages (-1=perform a refresh operation)
      Get prepare list parameter block format:
         0 data length
         2 number of hardware code pages
         4 hardware code pages
         n number of prepared code pages
       n+2 prepared code pages
      Display info parameter block format:
         0 info level (must be 0)
         1 reserved
         2 data length (14)
         4 flags
           Bit 0 (0=blink,1=intensity)
         6 mode (1=text,2=graphics)
         7 reserved
         8 colors
        10 pixel columns
        12 pixel rows
        14 character columns
        16 character rows
   0D Generic IOCTL for drives (3.2+)
      Entry: BL=drive code (0=default)
             CH=category code (08=disk)
             CL=function code
                40 set device parameters
                41 write track
                42 format track
                46 set media info (4.0+)
                47 set access flag (4.0+)
                60 get device parameters
                61 read track
                62 verify track
                66 get media info (4.0+)
                67 get access flag (4.0+)
                68 sense media type (5.0+)
             DS:DX->parameter block
      Exit:  CF=0 None
             CF=1 AX=error code
      Get/set device parameter block format:
         0 flags (only bit 0 is used by get)
           Bit 0 0=return default BPB/build new BPB
                 1=return build BPB/use device BPB
               1 0=read all fields
                 1=read track layout only
               2 0=sector sizes vary
                 1=sector sizes equal
         1 drive type
           0=360K             5=fixed
           1=1.2M             6=tape
           2=720K             7=1.44M
           3=8" single sided  8=read/write optical
           4=8" double sided  9=2.88M
         2 attributes
           Bit 0 1=non-removable
               1 1=changeline supported
         4 cylinders
         6 density (0=high,1=double)
         7 BIOS parameter block
        32 reserved
        38 track layout count
        40 track layout words (sector number,sector size)
        Note: Track layout fields are used by set only.
      Read/write parameter block format:
         0 reserved
         1 head
         3 cylinder
         5 sector
         7 number of sectors
         9 buffer address
      Format/verify parameter block format:
         0 reserved
         1 head
         3 cylinder
      Get/set media info parameter block format:
         0 info level (must be 0)
         2 volume serial number
         6 volume label
        17 8-byte file system type
      Get/set access flag parameter block format:
         0 reserved
         1 access flag (0=disallow disk access,1=allow disk access)
      Sense media type parameter block format:
         0 media type flag (0=other,1=default)
         1 media type (2=720K,7=1.44M,9=2.88M)
   0E Get logical drive map (3.2+)
   0F Set logical drive map (3.2+)
      Entry: BL=logical drive code (0=default)
      Exit:  CF=0 AL=physical drive code (0=only 1 logical drive mapped)
             CF=1 AX=error code
   10 Query IOCTL for handles (5.0+)
      Entry: BX=file handle
             CH=category code (01=AUX,03=CON,05=PRN)
             CL=function code
      Exit:  CF=0 None
             CF=1 AX=error code
   11 Query IOCTL for drives (5.0+)
      Entry: BL=drive code (0=default)
             CH=category code (08=disk)
             CL=function code
      Exit:  CF=0 None
             CF=1 AX=error code
45 Duplicate handle (2.0+)
   Entry: BX=file handle
   Exit:  CF=0 AX=new file handle
          CF=1 AX=error code
46 Redirect handle (2.0+)
   Entry: BX=file handle
          CX=file handle to redirect
   Exit:  CF=0 None
          CF=1 AX=error code
   Note:  If the handle to redirect is opened then it is closed before
          being redirected.
47 Get current directory (2.0+)
   Entry: DS:SI->64-byte buffer for pathname
          DL=drive code (0=default)
   Exit:  CF=0 None
          CF=1 AX=error code
48 Allocate memory (2.0+)
   Entry: BX=number of paragraphs to allocate
   Exit:  CF=0 AX=segment of allocated block
          CF=1 AX=error code
               BX=size of largest available block
49 Release memory (2.0+)
   Entry: ES=segment of block to release
   Exit:  CF=0 None
          CF=1 AX=error code
4A Reallocate memory (2.0+)
   Entry: BX=number of paragraphs to allocate
          ES=segment of block to reallocate
   Exit:  CF=0 None
          CF=1 AX=error code
               BX=size of largest available block
4B Execute program (2.0+)
   Entry: AL=0 execute program
          AL=1 load program
          AL=3 load overlay
          AL=5 enter exec state (5.0+)
          DS:DX->filename or exec state parameter block
          ES:BX->parameter block (unused by enter exec state)
             if function 00 or 01:
                0 environment block segment or 0
                2 command tail pointer
                6 FCB1 pointer
               10 FCB2 pointer
             if function 03:
                0 segment where file will be loaded
                2 relocation factor
             if function 05:
                0 reserved
                2 flags (0=COM,1=EXE,2=overlay)
                4 program name pointer
                8 PSP
               10 program CS:IP
               14 doubleword program size
   Exit:  CF=0 BX and DX may be destroyed
               parameter block if load only:
                 14 SS:SP of loaded program
                 18 CS:IP of loaded program
          CF=1 AX=error code
   Note:  After calling function 4B01 the current PSP is set to that of
          the loaded program. Before executing the program, DS and ES
          should be set to the program's PSP and the INT 22 vector in the
          program's PSP should be set to a valid return address.
4C Terminate with return code (2.0+)
   Entry: AL=return code
   Exit:  Does not return to caller
4D Get program return code (2.0+)
   Entry: None
   Exit:  AL=return code
          AH=exit type (0=normal,1=Ctrl-C,2=critical error,3=TSR)
4E Find first file (2.0+)
   Entry: DS:DX->filespec
          CX=file attributes
   Exit:  CF=0 DTA    search drive code (1=A)
               DTA+1  search filespec
               DTA+12 search attribute byte
               DTA+13 directory entry offset
               DTA+15 directory cluster (0=root)
               DTA+17 unused
               DTA+21 attribute byte (40h=character device)
               DTA+22 file time
               DTA+24 file date
               DTA+26 file size
               DTA+30 filename
          CF=1 AX=error code
4F Find next file (2.0+)
   Entry: Bytes 0-20 of buffer at DTA must be set from previous 4E or 4F call
   Exit:  Same as function 4E
50 Set current PSP (2.0+)
   Entry: BX=PSP segment
   Exit:  None
51 Get current PSP (2.0+)
   Entry: None
   Exit:  BX=PSP segment
52 Get DOS internal pointers (*) (2.0+)
   Entry: None
   Exit:  ES:BX->DOS internal pointers
            -02h memory chain anchor
            +00h pointer to disk parameter blocks
            +04h pointer to system file tables
            +08h pointer to CLOCK$ device header
            +0Ch pointer to CON device header
            +10h disk buffer size
            +12h pointer to disk buffer chain (3.x)
                 pointer to disk buffer control block (4.0+)
            +16h pointer to current directory structures
            +1Ah pointer to FCB system file tables
            +1Eh FCB keep count
            +20h number of actual drives
            +21h number of logical drives
            +22h NUL device header
53 Create disk parameter block (*) (2.0+)
   Entry: DS:SI->BIOS parameter block
             0 bytes per sector
             2 sectors per cluster
             3 number of reserved sectors
             5 number of FATs
             6 number of root directory entries
             8 total number of sectors
            10 media descriptor byte
            11 sectors per FAT
            13 sectors per track
            15 number of heads
            17 number of hidden sectors
            21 32-bit number of sectors if word at 8=0
          ES:BP->buffer for disk parameter block
   Exit:  None
54 Get verify flag (2.0+)
   Entry: None
   Exit:  AL=verify flag (0=off,1=on)
55 Create program PSP (*) (2.0+)
   Entry: DX=segment for new PSP
          SI=new end of allocation
   Exit:  None
   Note:  After calling function 55 the current PSP is set to the new PSP.
56 Rename file (2.0+)
   Entry: DS:DX->old filename
          ES:DI->new filename
   Exit:  CF=0 None
          CF=1 AX=error code
   Note:  This function can also rename a directory or move a file from
          one directory to another.
57 Get or set file date and time (2.0+)
   Entry: AL=0 get date and time
          AL=1 set date and time
          BX=file handle
          CX=time if set
             Bits 0-4 seconds/2 (0-29)
                 5-10 minutes (0-59)
                11-15 hours (0-23)
          DX=date if set
             Bits 0-4 day (1-31)
                  5-8 month (1-12)
                 9-15 year-1980
   Exit:  CF=0 CX=time if get
               DX=date if get
          CF=1 AX=error code
58 Get or set allocation strategy (2.11+)
   Entry: AL=0 get strategy
          AL=1 set strategy
          AL=2 get UMB link state (5.0+)
          AL=3 set UMB link state (5.0+)
          BX=strategy code or UMB link state (0=unlink,1=link)
             00=first fit
             01=best fit
             02=last fit
             40=first fit, high only (5.0+)
             41=best fit, high only (5.0+)
             42=last fit, high only (5.0+)
             80=first fit, high first (5.0+)
             81=best fit, high first (5.0+)
             82=last fit, high first (5.0+)
   Exit:  CF=0 AX=strategy code or UMB link state if get
          CF=1 AX=error code
59 Get extended error info (3.0+)
   Entry: None
   Exit:  AX=extended error code
          BH=error class
          BL=suggested action
          CH=locus
          ES:DI->volume label for invalid disk change error or 0
5A Create unique file (3.0+)
   Entry: DS:DX->pathname ending with \
          CX=file attributes
   Exit:  CF=0 AX=file handle (filename is appended to pathname)
          CF=1 AX=error code
5B Create new file (3.0+)
   Entry: DS:DX->filename
          CX=file attributes
   Exit:  CF=0 AX=file handle
          CF=1 AX=error code
5C Lock or unlock file (3.0+)
   Entry: AL=0 lock
          AL=1 unlock
          BX=file handle
          CX:DX=region offset
          SI:DI=region length
   Exit:  CF=0 None
          CF=1 AX=error code
   Note:  File sharing (SHARE.EXE) must be loaded to use this function.
5D File sharing functions (*) (3.0+)
   Notes: 1) Some functions use a parameter block with the following format:
             AX,BX,CX,DX,SI,DI,DS,ES,reserved,machine #,process (PSP)
          2) Functions 02-05 work only if file sharing (SHARE.EXE) is loaded.
          3) Functions 07-09 work only if the redirector (REDIR.EXE) is loaded.
   00 Server DOS call (*) (3.0+)
      Entry: DS:DX->parameter block (AX,BX,CX,DX,SI,DI,DS,ES,machine #,process)
      Exit:  Depends on called function
   01 Commit all local files (*) (3.0+)
      Entry: None
      Exit:  None
   02 Close all occurences of file (*) (3.0+)
      Entry: DS:DX->parameter block (DS:DX->qualified filespec)
      Exit:  CF=0 None
             CF=1 AX=error code
   03 Close all files for machine (*) (3.0+)
      Entry: DS:DX->parameter block (machine #)
      Exit:  CF=0 None
             CF=1 AX=error code
   04 Close all files for machine and process (*) (3.0+)
      Entry: DS:DX->parameter block (machine #,process)
      Exit:  CF=0 None
             CF=1 AX=error code
   05 Get shared file info (*) (3.0+)
      Entry: DS:DX->parameter block (BX=share file table index,CX=SFT index)
      Exit:  CF=0 AX=device info from SFT
                  BX=machine #
                  CX=lock count
                  ES:DI->qualified filename
             CF=1 AX=error code
   06 Get DOS swappable data area (*) (3.0+)
      Entry: None
      Exit:  DS:SI->DOS swappable data area
             CX=DOS swappable data area length
             DX=DOS critical data area length
      Note:  The first byte of the data area is the critical error flag.
   07 Get print stream state (*) (3.1+)
      Entry: None
      Exit:  DL=state (0=truncate off,1=truncate on)
   08 Set print stream state (*) (3.1+)
      Entry  DL=state (0=truncate off,1=truncate on)
      Exit:  None
   09 Truncate print stream (*) (3.1+)
      Entry  None
      Exit:  None
   0A Set extended error info (3.1+)
      Entry: DS:DX->parameter block (see function 59 for affected registers)
      Exit:  None
5E Network functions (3.0+)
   Note: Functions 02-05 work only if the redirector (REDIR.EXE) is loaded.
   00 Get machine name (3.0+)
      Entry: DS:DX->buffer for machine name
      Exit:  CH=validity flag (0=invalid,1=valid)
             CL=netbios number
   01 Set machine name (*) (3.0+)
      Entry: DS:DX->machine name
             CH=validity flag (0=invalid,1=valid)
             CL=netbios number
      Exit:  None
   02 Set printer string (3.1+)
      Entry: DS:SI->printer setup string
             BX=redirection list index
             CX=printer setup string length
      Exit:  CF=0 None
             CF=1 AX=error code
   03 Get printer string (3.1+)
      Entry: ES:DI->buffer for printer setup string
             BX=redirection list index
      Exit:  CF=0 CX=printer setup string length
             CF=1 AX=error code
   04 Set print mode (*) (3.1+)
      Entry: BX=redirection list index
             DX=print mode (0=text,1=binary)
      Exit:  CF=0 None
             CF=1 AX=error code
   05 Get print mode (*) (3.1+)
      Entry: BX=redirection list index
      Exit:  CF=0 DX=print mode (0=text,1=binary)
             CF=1 AX=error code
5F Network redirection functions (3.1+)
   Notes: 1) Functions 00-05 work only if the redirector (REDIR.EXE) is loaded.
          2) Functions 07-08 work only on builtin drives.
   00 Get redirection mode (*) (3.1+)
      Entry: BL=device type (3=printer,4=disk)
      Exit:  CF=0 BH=redirection mode (0=off,1=on)
             CF=1 AX=error code
   01 Set redirection mode (*) (3.1+)
      Entry: BL=device type (3=printer,4=disk)
             BH=redirection mode (0=off,1=on)
      Exit:  CF=0 None
             CF=1 AX=error code
   02 Get redirection list entry (3.1+)
      Entry: DS:SI->16-byte buffer for local device name
             ES:DI->128-byte buffer for remote device name
             BX=redirection list index
      Exit:  CF=0 BH=status (0=valid,1=invalid)
                  BL=device type (3=printer,4=disk)
                  CX=user word
             CF=1 AX=error code
   03 Set redirection list entry (3.1+)
      Entry: DS:SI->local device name
             ES:DI->remote device name
             BL=device type (3=printer,4=disk)
             CX=user word
      Exit:  CF=0 None
             CF=1 AX=error code
   04 Cancel redirection list entry (3.1+)
      Entry: DS:SI->local device name
      Exit:  CF=0 None
             CF=1 AX=error code
   05 Get redirection list entry extended (*) (4.0+)
      Entry: DS:SI->16-byte buffer for local device name
             ES:DI->128-byte buffer for remote device name
             BX=redirection list index
      Exit:  CF=0 BH=status (0=valid,1=invalid)
                  BL=device type (3=printer,4=disk)
                  CX=user word
                  BP=netbios session number
             CF=1 AX=error code
   07 Enable drive (*) (4.0+)
      Entry: DL=drive code (0=default)
      Exit:  CF=0 None
             CF=1 AX=error code
   08 Disable drive (*) (4.0+)
      Entry: DL=drive code (0=default)
      Exit:  CF=0 None
             CF=1 AX=error code
60 Qualify filename (*) (3.0+)
   Entry: DS:SI->filespec
          ES:DI->buffer for qualified filespec
   Exit:  CF=0 None
          CF=1 AX=error code
61 Reserved
62 Get current PSP (3.0+)
   Entry: None
   Exit:  BX=PSP segment
63 Get DBCS lead byte table pointer (*) (3.0+)
   Entry: AL must be 0
   Exit:  DS:SI->DBCS lead byte table
64 Set wait for external event flag (*) (3.2+)
   Entry: AL=flag (0=enable,>0=disable)
   Exit:  None
   Note:  This function affects the PC Convertible only.
          If enabled and the default console driver is being used then
          INT 15 function 41 is issued while waiting for console input
          during functions 01,08,0A,and 3F.
65 Get extended country info (3.3+)
   Entry: AL=01 get extended country info
             02 get country uppercase table
             03 get country lowercase table (reserved until 6.2)
             04 get country filename uppercase table
             05 get country filename character table
             06 get country collating table
             07 get DBCS vector table (4.0+)
             20 uppercase character (4.0+)
             21 uppercase string (4.0+)
             22 uppercase ASCIIZ string (4.0+)
             23 yes/no check (*) (4.0+)
             A0 uppercase filename character (*) (4.0+)
             A1 uppercase filename string (*) (4.0+)
             A2 uppercase filename ASCIIZ string (*) (4.0+)
             A3 yes/no check (*) (4.0+)
          if function 01-07:
             BX=code page (-1=active code page)
             CX=length to return (must be at least 5)
             DX=country code (-1=default)
             ES:DI->return buffer
          if function 20,23,A0,A3:
             DL=character
          if function 21,A1:
             DS:DX->string
             CX=string length
          if function 22,A2:
             DS:DX->string
   Exit:  CF=0 CX=data length if function 01-07
               DL=character if function 20
               AX=code if function 23,A3 (0=no,1=yes,2=neither)
          CF=1 AX=error code
          buffer format if function 01:
           0 info ID
           1 length
           3 country code
           5 code page
           7 country info (same format as function 38)
          buffer format if function 02-07:
           0 info ID
           1 pointer to requested table (word length followed by data)
66 Get or set code page (3.3+)
   Entry: AL=1 get code page
          AL=2 set code page
          BX=active code page if set
   Exit:  CF=0 BX=active code page if get
               DX=default code page if get
          CF=1 AX=error code
67 Set handle count (3.3+)
   Entry: BX=handle count
   Exit:  CF=0 None
          CF=1 AX=error code
68 Commit file (3.3+)
   Entry: BX=file handle
   Exit:  CF=0 None
          CF=1 AX=error code
69 Get or set media info (*) (4.0+)
   Entry: AL=0 get media info
          AL=1 set media info
          BL=drive code (0=default)
          DS:DX->media info
   Exit:  CF=0 None
          CF=1 AX=error code
   Media info format:
      0 info level (must be 0)
      2 volume serial number
      6 volume label
     17 8-byte file system type
6A Commit file (*) (4.0+)
   Entry: Same as function 68
   Exit:  Same as function 68
6B Reserved
6C Extended open/create file (4.0+)
   Entry: DS:SI->filename
          BX=open mode
             Bit 0-2 access mode
                     000=read
                     001=write
                     010=read/write
                 4-6 sharing mode
                     000=compatibility
                     001=deny read/write access
                     010=deny write access
                     011=deny read access
                     100=deny none access
                   7 inheritance flag
                     0=file inherited by EXECed programs
                     1=file not inherited by EXECed programs
                  13 critical error handling
                     0=execute INT 24
                     1=return error code
                  14 buffering
                     0=buffer writes
                     1=don't buffer writes
          CX=file attributes
          DX=open flags
             Bit 0-3 0000=fail if exists
                     0001=open if exists
                     0010=truncate if exists
                 4-7 0000=fail if doesn't exist
                     0001=create if doesn't exist
   Exit:  CF=0 AX=file handle
               CX=action code (1=file opened,2=file created,3=file truncated)
          CF=1 AX=error code

INT 22 Terminate address (1.0+)
       This is the address that DOS returns to after program termination.
       It is set during execute program (function 4B) processing.

INT 23 Ctrl-Break handler address (1.0+)
       This routine is entered when Ctrl-Break is detected by DOS.
       On entry the registers are set to the values they had at the start
       of the interrupted function call. Control may be returned via
       IRET or FAR RET, if FAR RET is used and the carry flag is set
       then the program is aborted otherwise the function is restarted.
Note:  Any DOS function may be issued from an INT 23 handler.

INT 24 Critical error handler address (1.0+)
Entry: AH=error indicator
          Bit 0 0=read error
                1=write error
            1-2 disk area
                00=DOS area
                01=FAT
                10=directory
                11=data area
              3 1=fail allowed
              4 1=retry allowed
              5 1=ignore allowed
              7 0=block device error
                1=character device error
       AL=drive code (0=A)
       DI=error code (lower half of DI)
          00=write-protect error           07=unknown media type
          01=unknown unit                  08=sector not found
          02=drive not ready               09=printer out of paper
          03=unknown command               0A=write fault
          04=data error (CRC)              0B=read fault
          05=bad request structure length  0C=general failure
          06=seek error                    0F=invalid disk change
       BP:SI=pointer to device driver header
Exit:  Control may be returned to DOS via IRET with an action code in AL
          0=ignore error (fail if ignore is unallowed)
          1=retry function (fail if retry is unallowed)
          2=abort program
          3=fail system call (abort if fail is unallowed)
       Control may be returned directly to the program by removing the
       INT 24 registers (IP,CS,flags) from the stack, restoring the
       program's registers (AX,BX,CX,DX,SI,DI,BP,DS,ES) and issuing
       an IRET. This will leave DOS in an unstable state because the
       critical error flag is set until a DOS function other than 01-0C,
       33,50,51,59,62,or 64 is issued.
Note:  Only DOS functions 01-0C,33,50,51,59,62,or 64 should be issued from
       an INT 24 handler.

INT 25 Absolute disk read (1.0+)
Entry: AL=drive number (0=A)
       CX=number of sectors or -1 if >32M partition
       DX=starting sector number
       DS:BX->data buffer or parameter block
         parameter block (3.31+)
           0 starting sector number
           4 number of sectors
           6 data buffer
Exit:  CF=0 None
       CF=1 AH=error code
               01=bad command
               02=bad address mark
               03=write-protect error
               04=sector not found
               08=DMA overrun
               10=data error (bad CRC)
               20=controller error
               40=seek error
               80=timed-out
            AL=device error code (same as lower byte of DI for INT 24)
Notes: 1) The CPU flags are still on the stack after an INT 25 or INT 26.
       2) All registers except the segment registers and SP may be destroyed.

INT 26 Absolute disk write (1.0+)
Entry: Same as INT 25
Exit:  Same as INT 25

INT 27 Terminate and stay resident (1.0+)
Entry: CS=PSP
       DX=number of bytes to stay resident (minimum 96)
Exit:  Does not return to caller

INT 28 Idle handler (2.0+)
       This interrupt is issued by DOS during functions 01-0C to indicate
       that a TSR program may safely issue a non-character I/O DOS
       function even though the InDOS flag is not zero.
       DOS functions 01-0C should not be issued from a INT 28 handler
       unless the critical error flag is set first.

INT 29 Character output (2.0+)
Entry: AL=character
Exit:  None
Note:  This interrupt is called for character output if the console
       device has bit 4 in the device attribute word set.

INT 2A Network/critical section (*) (3.0+)
00 Network installation check (3.0+)
   Entry: None
   Exit:  AH=00 not installed
          AH=FF installed
01 Execute NETBIOS request with no error retry (*) (3.0+)
   Entry: ES:BX->network control block
   Exit:  AH=0 no error
          AH=1 AL=error code
02 Set network printer parameters (*) (3.0+)
   Entry: DS:SI->16-byte buffer for local device name
          BX=characters per line (-1=use current)
          CX=lines per inch (-1=use current)
   Exit:  CF=0 None
          CF=1 AX=error code
03 Check direct I/O (3.0+)
   Entry: DS:SI->ASCIIZ disk name (d:)
   Exit:  CF=0 direct I/O allowed
          CF=1 direct I/O not allowed
04 Execute NETBIOS request (3.0+)
   Entry: AL=error retry flag (0=retry,1=no retry)
          ES:BX->network control block
   Exit:  AH=0 no error
          AH=1 AL=error code
05 Get network resource information (3.0+)
   Entry: None
   Exit:  BX=available network name count
          CX=available network control block count
          DX=available network session count
06 Network print stream control (3.0+)
   Entry: AL=mode (1=concatenation,2=truncation,3=truncate stream)
   Exit:  CF=0 None
          CF=1 AX=error code
80 Begin critical section (*) (3.0+)
   Entry: AL=critical section number
   Exit:  None
81 End critical section (*) (3.0+)
   Entry: AL=critical section number
   Exit:  None
82 End all critical sections (*) (3.0+)
   Entry: None
   Exit:  None
84 Keyboard idle loop (*) (3.0+)
   Entry: None
   Exit:  None

INT 2E Execute command (*) (2.0+)
Entry: DS:SI->command string-1 followed by a carriage return
Exit:  All registers except CS and IP are destroyed
Note:  This function is not re-entrant and should not be issued from a
       batch file.

INT 2F Multiplex (3.0+)
Entry: AH=program identifier
       AL=function code
       Other registers depend on the function
Exit:  Depends on the function

Program identifier codes:
01 Print queueing (PRINT) (3.0+)
02 Network printer control (REDIR) (3.1+)
05 Network error message lookup (REDIR) (3.0+)
06 ASSIGN (3.1+)
08 IBMBIO drive services (used by DRIVER.SYS) (3.2+)
10 File sharing (SHARE) (3.0+)
11 Redirector services (REDIR and MSCDEX) (3.0+)
12 DOS internal services (used by REDIR and MSCDEX) (3.0+)
13 Swap INT 13 vector (3.2+)
14 NLS support (NLSFUNC) (3.3+)
15 CD-ROM extensions (MSCDEX)
16 Windows services
17 Windows clipboard services
1A ANSI.SYS (4.0+)
43 XMS services (HIMEM.SYS)
46 Windows support
48 DOSKEY (5.0+)
4A DOS services (HMA, RPL), SMARTDRV (5.0+)
53 POWER (APM events broadcast) (5.02+)
54 POWER (main API) (5.02+)
55 COMMAND.COM (5.0+)
56 INTERLNK (5.02+)
AC GRAPHICS (5.0+)
AD DISPLAY.SYS, KEYB (3.3+)
AE Installable command support (APPEND) (3.3+)
B0 GRAFTABL (3.3+)
B7 APPEND (3.2+)

DOS extended error information:

Extended error code:                    Error class:
01 Invalid function number              01 Out of resource
02 File not found                       02 Temporary situation
03 Path not found                       03 Authorization error
04 Too many open files                  04 Internal DOS error
05 Access denied                        05 Hardware failure
06 Invalid handle                       06 System software failure
07 Memory control blocks destroyed      07 Application program error
08 Insufficient memory                  08 Not found
09 Invalid memory block address         09 Invalid format
0A Invalid environment                  0A File locked
0B Invalid format                       0B Media error
0C Invalid access code                  0C Already exists
0D Invalid data                         0D Unknown
0E Reserved
0F Invalid drive                        Suggested action:
10 Attempt to remove current directory  01 Retry
11 Not same device                      02 Delay and retry
12 No more files                        03 Get corrected user input
13 Write-protect error                  04 Exit with cleanup
14 Unknown unit                         05 Exit without cleanup
15 Drive not ready                      06 Ignore error
16 Unknown command                      07 Retry after user intervention
17 Data error (CRC)
18 Bad request structure length         Error locus:
19 Seek error                           01 Unknown
1A Unknown medium type                  02 Block device error
1B Sector not found                     03 Network error
1C Printer out of paper                 04 Character device error
1D Write fault                          05 Memory error
1E Read fault
1F General failure
20 Sharing violation
21 Lock violation
22 Invalid disk change
23 FCB unavailable
24 Sharing buffer overflow
25 Code page mismatch (4.0+)
26 Out of input (4.0+)
27 Insufficient disk space (4.0+)
32 Function not supported
41 Network access denied
50 File exists
51 Reserved
52 Cannot make directory entry
53 Fail on INT 24
