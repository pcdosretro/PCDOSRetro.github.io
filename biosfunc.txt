INT 02 Non-maskable Interrupt (NMI)
       This interrupt is issued if a parity error occurs or if interrupts
       are disabled for too long and the watchdog timer was enabled.
       This interrupt may also be generated by a device such as a hardware
       debugger.

INT 05 Print screen
       Entry: None
       Exit:  50:0=00 print screen successful
              50:0=01 print screen in progress
              50:0=FF error occurred

INT 08 Timer (IRQ 0)
       This interrupt is issued 18.2 times per second and is responsible
       for updating the system timer at 40:6C, resetting diskette drive
       motors, and issuing INT 1C.

INT 09 Keyboard (IRQ 1)
       This interrupt is issued for every key press and release.
       It is responsible for updating the keyboard buffer and status bytes,
       handling the Pause key, resetting the computer (Ctrl-Alt-Del),
       issuing INT 5 (PrtSc), INT 15 function 4F (Keyboard intercept),
       INT 15 function 85 (SysReq), INT 1B (Ctrl-Break).

INT 0A Redirect (IRQ 2)
       This interrupt handles redirected interrupts from IRQ 9.

INT 0B Serial port 2 (IRQ 3)
       This interrupt is issued for a change in status on serial port 2.

INT 0C Serial port 1 (IRQ 4)
       This interrupt is issued for a change in status on serial port 1.

INT 0D Unused (IRQ 5)

INT 0E Floppy disk (IRQ 6)
       This interrupt is issued upon floppy disk I/O completion and is
       responsible for updating the floppy disk interrupt flag at 40:3E, bit 7.

INT 0F Parallel port or unused (IRQ 7)
       This interrupt is issued to indicate the printer is not busy.

INT 10 Video
Note: When an EGA or VGA is installed the original video interrupt is
      revectored to INT 42.
00 Set video mode
   Entry: AL=video mode
             00 40x25 text (color burst off)
             01 40x25 text
             02 80x25 text (color burst off)
             03 80x25 text
             04 320x200 4-color graphics
             05 320x200 4-color graphics (color burst off)
             06 640x200 2-color graphics
             07 80x25 monochrome text (MDA)
             0D 320x200 16-color graphics (EGA/VGA)
             0E 640x200 16-color graphics (EGA/VGA)
             0F 640x350 monochrome graphics (EGA/VGA)
             10 640x350 4-color or 16-color graphics (EGA/VGA)
             11 640x480 2-color graphics (MCGA/VGA)
             12 640x480 16-color graphics (VGA)
             13 320x200 256-color graphics (MCGA/VGA)
   Exit:  None
   Note:  For EGA/MCGA/VGA if bit 7 of AL is set the screen is not cleared.
01 Set cursor type
   Entry: CH=cursor start line
          CL=cursor end line
   Exit:  None
   Notes: 1) Legal values are 0-7 (CGA) and 0-13 (MDA)
             Default values are 6,7 (CGA) and 11,12 (MDA)
          2) Setting CH=20 will make the cursor disappear
02 Set cursor position
   Entry: BH=page number
          DH=row
          DL=column
   Exit:  None
03 Get cursor position
   Entry: BH=page number
   Exit:  CH=cursor start line
          CL=cursor end line
          DH=row
          DL=column
04 Read light pen position
   Entry: None
   Exit:  AH=status (0=not triggered,1=triggered)
          BX=pixel column
          CH=pixel row (modes 04-06)
          CX=pixel row (modes 0D-13)
          DH=character row
          DL=character column
05 Select display page
   Entry: AL=page number
             0-1 for modes 0F,10
             0-3 for modes 02-03(CGA),0E
             0-7 for modes 00-01,02-03(EGA/MCGA/VGA),07(EGA/VGA),0D
   Exit:  None
06 Scroll window up
   Entry: AL=number of lines to scroll or 0 to blank window
          BH=blanking attribute
          CH=upper left corner of window (row)
          CL=upper left corner of window (column)
          DH=lower right corner of window (row)
          DL=lower right corner of window (column)
   Exit:  None
07 Scroll window down
   Entry: Same as function 06
   Exit:  None
08 Read attribute and character at cursor
   Entry: BH=page number
   Exit:  AH=attribute (text modes)
          AL=character
09 Write attribute and character at cursor
   Entry: AL=character
          BH=page number
          BL=attribute (text modes) or color (graphics modes)
          CX=repetition count
   Exit:  None
   Notes: 1) The repetition count is valid only for the current row in
             graphics modes.
          2) If bit 7 of BL is set for graphics modes the character is
             XORed with the current character contents.
0A Write character at cursor
   Entry: AL=character
          BH=page number
          CX=repetition count
   Exit:  None
   Note:  The repetition count is valid only for the current row in
          graphics modes.
0B Set color palette
   Entry: BH=0, BL=background color (graphics modes) and border color
          BH=1, BL=palette (0=green/red/brown,1=cyan/magenta/white)
   Exit:  None
   Note:  This function is valid only for mode 04.
0C Write dot
   Entry: AL=pixel color
          BH=page number (EGA/VGA graphics modes)
          CX=column number
          DX=row number
   Exit:  None
   Note:  If bit 7 of AL is set for graphics modes the dot is XORed with
          the current dot contents.
0D Read dot
   Entry: BH=page number (EGA/VGA graphics modes)
          CX=column number
          DX=row number
   Exit:  AL=pixel color
0E Write teletype
   Entry: AL=character
          BL=color (graphics modes)
   Exit:  None
   Note:  The ASCII codes for bell,backspace,linefeed,and carriage return
          are processed appropriately.
0F Get video mode
   Entry: None
   Exit:  AH=number of columns
          AL=video mode
          BH=active page number
10 Set palette registers
   00 Set palette register (EGA/MCGA/VGA)
      Entry: BH=color value
             BL=palette register
      Exit:  None
   01 Set border color register (EGA/VGA)
      Entry: BH=color value
      Exit:  None
   02 Set palette and border registers (EGA/VGA)
      Entry: ES:DX->17-byte color list
      Exit:  None
   03 Toggle intensity/blink bit (EGA/MCGA/VGA)
      Entry: BL=0 enable intensity
             BL=1 enable blink
      Exit:  None
   07 Get palette register (VGA)
      Entry: BL=palette register
      Exit:  BH=color value
   08 Get border color register (VGA)
      Entry: None
      Exit:  BH=color value
   09 Get palette and border registers (VGA)
      Entry: ES:DX->17-byte color list
      Exit:  None
   10 Set color register (MCGA/VGA)
      Entry: BX=color register
             CH=green value
             CL=blue value
             DH=red value
      Exit:  None
   12 Set block of color registers (MCGA/VGA)
      Entry: BX=first color register
             CX=number of registers
             ES:DX->color register table
      Exit:  None
   13 Set color page state (VGA)
      Entry: BL=0, BH=paging mode
             BL=1, BH=color page
      Exit:  None
   15 Get color register (MCGA/VGA)
      Entry: BX=color register
      Exit:  CH=green value
             CL=blue value
             DH=red value
   17 Get block of color registers (MCGA/VGA)
      Entry: BX=first color register
             CX=number of registers
             ES:DX->color register table
      Exit:  None
   1A Get color page state (VGA)
      Entry: None
      Exit:  BH=color page
             BL=paging mode (0=4 pages/64 registers, 1=16 pages/16 registers)
   1B Set gray-scale values (MCGA/VGA)
      Entry: BX=first color register
             CX=number of registers
      Exit:  None
11 Character generator
   Notes: 1) Subfunctions 00-02 and 04 perform a mode set.
          2) Subfunctions 10-14 rely on page 0 being active.
             These subfunctions also recalculate the number of bytes
             per character, number of rows, and regen buffer size.
          3) Subfunctions 10-24 should only be called after a mode set.
          4) Subfunction 20 sets the INT 1F pointer.
          5) Subfunctions 21-24 set the INT 43 pointer.
   00 Load user-defined font (EGA/MCGA/VGA - text modes)
      Entry: ES:BP->font table
             BH=bytes per character
             BL=font block
             CX=character count
             DX=character offset
      Exit:  None
   01 Load 8x14 character font (EGA/MCGA/VGA - text modes)
      Entry: BL=font block
      Exit:  None
   02 Load 8x8 double-dot character font (EGA/MCGA/VGA - text modes)
      Entry: BL=font block
      Exit:  None
   03 Set block specifier (EGA/MCGA/VGA - text modes)
      Entry: BL=block specifier
                EGA:
                Bits 0-1: block to use when bit 3 of attribute byte=0
                Bits 2-3: block to use when bit 3 of attribute byte=1
                VGA:
                Bits 0,1,4: block to use when bit 3 of attribute byte=0
                Bits 2,3,5: block to use when bit 3 of attribute byte=1
      Exit:  None
   04 Load 8x16 character font (MCGA/VGA - text modes)
      Entry: BL=font block
      Exit:  None
   10 Load user-defined text font (EGA/MCGA/VGA - text modes)
      Entry: ES:BP->font table
             BH=bytes per character
             BL=font block
             CX=character count
             DX=character offset
      Exit:  None
   11 Load 8x14 character font (EGA/MCGA/VGA - text modes)
      Entry: BL=font block
      Exit:  None
   12 Load 8x8 double-dot character font (EGA/MCGA/VGA - text modes)
      Entry: BL=font block
      Exit:  None
   14 Load 8x16 character font (MCGA/VGA - text modes)
      Entry: BL=font block
      Exit:  None
   20 Load user-defined 8x8 character font (EGA/MCGA/VGA - graphics modes)
      Entry: ES:BP->font table for characters 128-255
      Exit:  None
   21 Load user-defined character font (EGA/MCGA/VGA - graphics modes)
      Entry: ES:BP->font table for characters 0-255
             CX=bytes per character
             BL=0 DL=rows
             BL=1 14 rows
             BL=2 25 rows
             BL=3 43 rows
      Exit:  None
   22 Load ROM 8x14 character font (EGA/MCGA/VGA - graphics modes)
      Entry: BL=rows (same as subfunction 21)
      Exit:  None
   23 Load ROM 8x8 double-dot character font (EGA/MCGA/VGA - graphics modes)
      Entry: BL=rows (same as subfunction 21)
      Exit:  None
   24 Load ROM 8x16 character font (MCGA/VGA - graphics modes)
      Entry: BL=rows (same as subfunction 21)
      Exit:  None
   30 Return font info (EGA/MCGA/VGA)
      Entry: BH=0 return INT 1F pointer
             BH=1 return INT 43 pointer
             BH=2 return ROM 8x14 font pointer
             BH=3 return ROM 8x8 double-dot font pointer (0-127)
             BH=4 return ROM 8x8 double-dot font pointer (128-255)
             BH=5 return ROM 9x14 alternate text pointer (EGA/VGA)
             BH=6 return ROM 8x16 font pointer (MCGA/VGA)
             BH=7 return ROM 9x16 alternate text pointer (VGA)
      Exit:  ES:BP=requested pointer
             CX=scan lines per character
             DL=rows (EGA) or rows-1 (MCGA/VGA)
12 Alternate select
   Note: Subfunction codes are in BL.
   10 Return EGA info (EGA/VGA)
      Entry: None
      Exit:  BH=display mode (0=color,1=monochrome)
             BL=memory (0=64K,1=128K,2=192K,3=256K)
             CH=adapter bits
             CL=DIP switch settings
   20 Select alternate print screen routine (EGA/MCGA/VGA)
      Entry: None
      Exit:  None
   30 Set text mode scan lines (VGA)
      Entry: AL=lines (0=200,1=350,2=400)
      Exit:  AL=12 (function supported)
      Note:  The scan line value takes effect on the next mode set.
   31 Enable/disable default palette loading (MCGA/VGA)
      Entry: AL=value (0=enable,1=disable)
      Exit:  AL=12 (function supported)
   32 Enable/disable video (MCGA/VGA)
      Entry: AL=value (0=enable,1=disable)
      Exit:  AL=12 (function supported)
   33 Enable/disable gray-scale summing (MCGA/VGA)
      Entry: AL=value (0=enable,1=disable)
      Exit:  AL=12 (function supported)
   34 Enable/disable cursor emulation (VGA)
      Entry: AL=value (0=enable,1=disable)
      Exit:  AL=12 (function supported)
   35 Display switch (MCGA/VGA)
      Entry: AL=0 disable initial video adapter (saves state in buffer)
             AL=1 enable system board video adapter
             AL=2 disable active video adapter (saves state in buffer)
             AL=3 enable inactive video adapter (restores state from buffer)
             ES:DX->128-byte video state buffer
      Exit:  AL=12 (function supported)
   36 Enable/disable screen refresh (VGA)
      Entry: AL=value (0=enable,1=disable)
      Exit:  AL=12 (function supported)
13 Write string (AT/EGA/MCGA/VGA)
   Entry: AL=0 string contains characters only
               cursor position is not updated after write
          AL=1 string contains characters only
               cursor position is updated after write
          AL=2 string contains characters and attributes
               cursor position is not updated after write
          AL=3 string contains characters and attributes
               cursor position is updated after write
          BH=page number
          BL=attribute
          CX=character count
          DH=row to write string
          DL=column to write string
          ES:BP->string
   Exit:  None
   Note:  The ASCII codes for bell,backspace,linefeed,and carriage return
          are processed appropriately.
1A Read/write display combination code (MCGA/VGA)
   Entry: AL=0 read display code
          AL=1 write display code
          BL=active display code if AL=1
          BH=alternate display code if AL=1
          Display codes:
            00=no display
            01=monochrome
            02=CGA
            04=EGA color
            05=EGA monochrome
            07=VGA monochrome
            08=VGA color
            0B=MCGA monochrome
            0C=MCGA color
   Exit:  AL=1A (function supported)
          BL=active display code if AL=0
          BH=alternate display code if AL=0
1B Get functionality/state info (MCGA/VGA)
   Entry: BX=0 (implementation type)
          ES:DI->64-byte buffer
            00 pointer to static functionality info
               00 supported modes (0-19; bit n: 1=mode n supported)
               03 reserved
               07 scan lines available in text modes
                  Bit 0 1=200
                      1 1=350
                      2 1=400
               08 font blocks available in text modes
               09 maximum active font blocks in text modes
               0A miscellaneous functions
                  Bit 0 1=all modes on all displays
                      1 1=gray-scale summing
                      2 1=character font loading
                      3 1=mode set default palette loading
                      4 1=cursor emulation
                      5 1=EGA palette
                      6 1=color palette
                      7 1=color paging
               0B miscellaneous functions
                  Bit 0 1=light pen
                      1 1=save/restore state
                      2 1=background intensity/blinking control
                      3 1=display combination code
               0C reserved
               0E save pointer functions
                  Bit 0 1=512-character set
                      1 1=dynamic savearea
                      2 1=alpha font override
                      3 1=graphics font override
                      4 1=palette override
                      5 1=display combination code extension
               0F reserved
            04 mode
            05 columns
            07 regen buffer size
            09 regen buffer start address
            0B cursor position (row,column) for 8 pages
            1B cursor type (start,end)
            1D active page
            1E CRT port address (3Bx=mono,3Dx=color)
            20 current setting of 3x8 register
            21 current setting of 3x9 register
            22 rows
            23 character height
            25 active display combination code
            26 alternate display combination code
            27 colors in current mode
            29 pages in current mode
            2A scan lines in current mode (0=200,1=350,2=400,3=480)
            2B primary character block
            2C secondary character block
            2D miscellaneous state info
               Bit 0 1=all modes on all displays active
                   1 1=gray-scale summing active
                   2 1=monochrome display attached
                   3 1=default palette loading disabled
                   4 1=cursor emulation active
                   5 0=intensity
                     1=blinking
            2E reserved
            31 video memory (0=64K,1=128K,2=192K,3=256K)
            32 save pointer state info
               Bit 0 1=512-character set active
                   1 1=dynamic savearea active
                   2 1=alpha font override active
                   3 1=graphics font override active
                   4 1=palette override active
                   5 1=display combination code extension active
            33 reserved
   Exit:  AL=1B (function supported)
1C Save/restore video state (VGA)
   Entry: AL=0 get video state buffer size
          AL=1 save video state
          AL=2 restore video state
          CX=requested states
             Bit 0 1=save/restore video hardware state
                 1 1=save/restore video BIOS data area
                 2 1=save/restore video DAC state and color registers
          ES:BX->video state buffer
   Exit:  AL=1C (function supported)
          BX=number of 64-byte blocks required for buffer if AL=0

INT 10 VESA Super VGA functions
4F00 Get Super VGA info
   Entry: ES:DI->512-byte return buffer
   Exit:  AL=4F (function supported)
          AH=status
             00 sucessful
             01 failed
             02 function not supported by current hardware configuration
             03 function not valid in current video mode
   Buffer format:
    0 VESA signature, set to VBE2 on entry for extended info
    4 VESA version (BCD)
    6 pointer to OEM name
   10 capabilities
      Bit 0 1=DAC can be switched into 8-bit mode
          1 1=non-VGA controller
          2 1=RAMDAC blanking required during programming
   14 pointer to supported modes list terminated by FFFF
   18 memory size in 64K blocks
   20 OEM software version (BCD)
   22 pointer to vendor name string
   26 pointer to product name string
   30 pointer to product revision string
   34 reserved
4F01 Get Super VGA mode info
   Entry: ES:DI->256-byte return buffer
          CX=mode
   Exit:  AL=4F (function supported)
          AH=status
   Buffer format:
    0 mode attributes
      Bit 0 1=mode supported
          1 1=optional info available
          2 1=TTY BIOS output supported
          3 0=mono,1=color
          4 0=text,1=graphics
          5 1=mode is not VGA-compatible
          6 1=windowed buffer mode not supported
          7 1=linear frame buffer mode supported
    2 window A attributes
      Bit 0 1=exists
          1 1=readable
          2 1=writable
    3 window B attributes
    4 window granularity in K
    6 window size in K
    8 window A segment
   10 window B segment
   12 window positioning function address (see function 4F05)
   16 bytes per scanline
   18 width in pixels or characters
   20 height in pixels or characters
   22 character width in pixels
   23 character height in pixels
   24 number of memory planes
   25 number of bits per pixel
   26 number of banks
   27 memory model type
      0 text
      1 CGA graphics
      2 HGC graphics
      3 16-color planar graphics
      4 packed pixel graphics
      5 256-color non-chain 4 graphics
      6 RGB color (color mask info valid)
      7 YUV color (color mask info valid)
   28 bank size in K
   29 number of image pages
   30 reserved
   31 red mask size
   32 red mask position
   33 green mask size
   34 green mask position
   35 blue mask size
   36 blue mask position
   37 reserved mask size
   38 reserved mask position
   39 direct color mode info
      Bit 0 1=color ramp is programmable
          1 1=reserved color field bits are usable
   40 physical address of linear frame buffer
   44 reserved
4F02 Set Super VGA mode
   Entry: BX=mode
          Bit 15 1=don't clear video memory
              14 1=use linear frame buffer
   Exit:  AL=4F (function supported)
          AH=status
4F03 Get Super VGA mode
   Entry: None
   Exit:  AL=4F (function supported)
          AH=status
          BX=mode
          Bit 15 1=video memory was not cleared on last mode set
              14 1=linear frame buffer mode
4F04 Save/restore Super VGA video state
   Entry: DL=0 get video state buffer size
          DL=1 save video state
          DL=2 restore video state
          CX=requested states
             Bit 0 1=save/restore video hardware state
                 1 1=save/restore video BIOS data area
                 2 1=save/restore video DAC state and color registers
                 3 1=save/restore video register state
          ES:BX->video state buffer
   Exit:  AL=4F (function supported)
          AH=status
          BX=number of 64-byte blocks required for buffer if DL=0
4F05 Super VGA video window control
   Entry: BH=0 set video memory window
          BH=1 get video memory window
          BL=window number (0=A,1=B)
          DX=window address if BH=0
   Exit:  AL=4F (function supported)
          AH=status
          DX=window address if BH=1
4F06 Super VGA set/get logical scanline length
   Entry: BL=0 set scanline length in pixels
          BL=1 get scanline length
          BL=2 set scanline length in bytes
          BL=3 get maximum scanline length
          CX=length in pixels if BL=0 or bytes if BL=2
   Exit:  AL=4F (function supported)
          AH=status
          BX=bytes per scanline (maximum if BL=3)
          CX=pixels per scanline (maximum if BL=3)
          DX=maximum number of scanlines
4F07 Super VGA set/get display start
   Entry: BL=0 set display start
          BL=1 get display start
          BL=80 set display start during vertical retrace
          BH=0 (reserved)
          CX=first displayed pixel in scanline if BL=0
          DX=first displayed scanline if BL=0
   Exit:  AL=4F (function supported)
          AH=status
          CX=first displayed pixel in scanline if BL=1
          DX=first displayed scanline if BL=1
4F08 Super VGA set/get DAC palette format
   Entry: BL=0 set DAC palette format
          BL=1 get DAC palette format
          BH=bits per primary color if BL=0
   Exit:  AL=4F (function supported)
          AH=status
          BH=current bits per primary color
4F09 Super VGA set/get palette data
   Entry: BL=0 set palette data
          BL=1 get palette data
          BL=2 set secondary palette data
          BL=3 get secondary palette data
          BL=80 set palette data during vertical retrace
          CX=number of entries
          DX=starting palette index
          ES:DI->palette buffer (4 bytes per entry: blue,green,red,unused)
   Exit:  AL=4F (function supported)
          AH=status
4F0A Return Super VGA protected mode interface
   Entry: BL=0
   Exit:  AL=4F (function supported)
          AH=status
          ES:DI->table and code
          CX=length of table and code
   Table format:
   0 offset of function 4F05 code
   2 offset of function 4F07 code
   4 offset of function 4F09 code
   6 offset of list of ports and memory locations which may need IOPL or 0
     ports... , FFFF , (dword address, word length)... , FFFF
     32-bit protected mode code (call functions with a near call)

INT 11 Get equipment flags
Entry: None
Exit:  AX=equipment flags (from 40:10)
          Bit 0 1=floppy drive(s) installed
              1 1=math coprocessor installed
              2 1=PS/2 mouse installed
              3 reserved
            4-5 initial video mode
                (1=40x25 color,2=80x25 color,3=80x25 mono)
            6-7 number of floppy drives-1
              8 reserved
           9-11 number of serial ports
             12 1=game port installed
             13 reserved
          14-15 number of parallel ports

INT 12 Get memory size
Entry: None
Exit:  AX=memory size in kilobytes (from 40:13)

INT 13 Disk
Notes: 1) Drive code values 80-87 specify fixed disks.
       2) When fixed disks are installed the original floppy disk
          interrupt is revectored to INT 40.
       3) Cylinder and head numbers are 0-based, sector numbers are 1-based.
00 Reset disk
   Entry: DL=drive code
   Exit:  CF=0 AH=0
          CF=1 AH=status
01 Get disk status
   Entry: DL=drive code
   Exit:  CF=0 AH=0
          CF=1 AH=status
                  01 illegal command
                  02 bad address mark
                  03 write-protect error
                  04 sector not found
                  05 reset failed
                  06 diskette was changed
                  07 set drive parameters failed
                  08 DMA overrun
                  09 attempt to DMA across 64K boundary
                  0A bad sector
                  0B bad track
                  0C media type not found
                  0D invalid number of sectors on format
                  10 data error (CRC)
                  11 ECC corrected data error
                  20 controller error
                  40 seek error
                  80 timed-out
                  AA drive not ready
                  BB undefined error
                  CC write fault
                  E0 status error
                  FF sense failed
02 Read sectors
   Entry: AL=number of sectors
          CH=cylinder number
          CL=sector number and high 2 bits of cylinder number
          DH=head number
          DL=drive code
          ES:BX->buffer
   Exit:  CF=0 AH=0
          CF=1 AH=status
03 Write sectors
   Entry: Same as function 02
   Exit:  Same as function 02
04 Verify sectors
   Entry: AL=number of sectors
          CH=cylinder number
          CL=sector number and high 2 bits of cylinder number
          DH=head number
          DL=drive code
   Exit:  CF=0 AH=0
          CF=1 AH=status
05 Format track
   Entry: AL=number of sectors (floppy disks) or interleave (XT fixed disks)
          CH=cylinder number
          CL=high 2 bits of cylinder number
          DH=head number
          DL=drive code
          ES:BX->address field list (AT fixed disks and floppy disks)
   Exit:  CF=0 AH=0
          CF=1 AH=status
   Address field format for fixed disks:
     0 sector flag (00=good sector,80=bad sector)
     1 sector number
   Address field format for floppy disks:
     0 track number
     1 head number
     2 sector number
     3 bytes per sector (0=128,1=256,2=512,3=1024)
06 Format track and set bad sector flags (XT fixed disks only)
   Entry: Same as function 05
   Exit:  Same as function 05
07 Format drive (XT fixed disks only)
   Entry: Same as function 05
   Exit:  Same as function 05
08 Get drive parameters
   Entry: DL=drive code
   Exit:  CF=0 AH=0
               BL=drive type (AT floppy disks only)
                  00=unknown
                  01=360K drive
                  02=1.2M drive
                  03=720K drive
                  04=1.44M drive
                  06=2.88M drive
                  10=ATAPI drive
               CH=maximum cylinder number
               CL=number of sectors and high 2 bits of maximum cylinder number
               DH=maximum head number
               DL=number of drives
               ES:DI->diskette drive parameter table (AT floppy disks only)
          CF=1 AH=status
   Note: INT 1E points to the current drive parameter table (11 bytes)
   Drive parameter table format:
    0 first specify byte
    1 second specify byte
    2 wait time until motor off
    3 bytes per sectors (0=128,1=256,2=512,3=1024)
    4 maximum sector number
    5 gap length
    6 data length
    7 gap length for format
    8 fill byte for format
    9 head settle time in milliseconds
   10 motor start time in 1/8 seconds
   11 maximum cylinder number
   12 data transfer rate in Kbits/second (80=250,40=300,00=500)
09 Init drive parameters (fixed disks only)
   Entry: DL=drive code
   Exit:  CF=0 AH=0
          CF=1 AH=status
   Note:  This function uses the drive tables vectored at
          INT 41 (drive 0) and INT 46 (drive 1)
   Drive table entry format:
    0 cylinders
    2 heads
    3 signature (A0 if translated table)
    4 physical sectors per cylinder (translated table)
    5 starting write precompensation cylinder
    7 reserved
    8 control byte
    9 physical cylinders (translated table)
   11 physical heads (translated table)
   12 parking cylinder
   14 sectors per cylinder
   15 checksum (translated table)
0A Read long (fixed disks only)
   Entry: AL=number of sectors
          CH=cylinder number
          CL=sector number and high 2 bits of cylinder number
          DH=head number
          DL=drive code
          ES:BX->buffer
   Exit:  CF=0 AH=0
          CF=1 AH=status
   Note:  Read and write long include 4 bytes of ECC data after each
          512-byte sector.
0B Write long (fixed disks only)
   Entry: Same as function 0A
   Exit:  Same as function 0A
0C Seek (fixed disks only)
   Entry: CH=cylinder number
          CL=high 2 bits of cylinder number
          DH=head number
          DL=drive code
   Exit:  CF=0 AH=0
          CF=1 AH=status
0D Alternate disk reset (fixed disks only)
   Entry: DL=drive code
   Exit:  CF=0 AH=0
          CF=1 AH=status
0E Read sector buffer (XT fixed disks only)
   Entry: ES:BX->buffer
   Exit:  CF=0 AH=0
          CF=1 AH=status
0F Write sector buffer (XT fixed disks only)
   Entry: Same as function 0E
   Exit:  Same as function 0E
10 Test drive ready (fixed disks only)
   Entry: DL=drive code
   Exit:  AH=status
11 Recalibrate drive (fixed disks only)
   Entry: DL=drive code
   Exit:  CF=0 AH=0
          CF=1 AH=status
12 Controller RAM diagnostics (XT fixed disks only)
   Entry: None
   Exit:  CF=0 AH=0
          CF=1 AH=status
13 Drive diagnostics (XT fixed disks only)
   Entry: DL=drive code
   Exit:  CF=0 AH=0
          CF=1 AH=status
14 Controller internal diagnostics (fixed disks only)
   Entry: DL=drive code
   Exit:  CF=0 AH=0
          CF=1 AH=status
15 Get disk type
   Entry: DL=drive code
   Exit:  CF=0 AH=disk type
                  0=drive not present
                  1=changeline not supported
                  2=changeline supported
                  3=fixed disk
               CX:DX=number of sectors (fixed disks only)
          CF=1 AH=status
16 Get disk change status (floppy disks only)
   Entry: DL=drive code
   Exit:  AH=changeline status
             00=changeline not active
             01=invalid diskette parameter
             06=changeline active
             80=drive not ready
17 Set disk type (floppy disks only)
   Entry: DL=drive code
          AL=disk type
             1=360K disk in 360K drive
             2=360K disk in 1.2M drive
             3=1.2M disk in 1.2M drive
             4=720K disk in 720K drive
   Exit:  CF=0 AH=0
          CF=1 AH=status
18 Set media type (floppy disks only)
   Entry: CH=maximum cylinder number
          CL=sectors per cylinder and high 2 bits of maximum cylinder number
          DL=drive code
   Exit:  CF=0 AH=0
               ES:DI->diskette drive parameter table
          CF=1 AH=status
19 Park heads (later PS/2 systems only)
   Entry: DL=drive code
   Exit:  CF=0 AH=0
          CF=1 AH=status
20 Sense media type (later systems - floppy disks only)
   Entry: DL=drive code
   Exit:  CF=0 AH=0
               AL=media type
                  03=720K
                  04=1.44M
                  06=2.88M
                  0C=360K
                  0D=1.2M
                  10=ATAPI
          CF=1 AH=status

INT 13 Enhanced Disk Drive (EDD)
Disk address packet format:
 0 packet size (16)
 1 reserved
 2 block count (set to number of blocks transferred)
 4 buffer address
 8 64-bit block number

41 EDD installation check
   Entry: DL=drive code
          BX=55AA
   Exit:  CF=0 AH=EDD version (BCD)
               BX=AA55
               CX=support bitmap
                  Bit 0 1=extended disk access functions (42,43,44,47,48)
                      1 1=removable media functions (45,46,48,49,INT 15/52)
                      2 1=enhanced disk drive functions (48 with extensions,4E)
          CF=1 AH=status
42 EDD extended read
   Entry: DL=drive code
          DS:SI->disk address packet
   Exit:  CF=0 AH=0
          CF=1 AH=status
43 EDD extended write
   Entry: DL=drive code
          AL=verify flag (1=verify write)
          DS:SI->disk address packet
   Exit:  CF=0 AH=0
          CF=1 AH=status
44 EDD extended verify
   Entry: DL=drive code
          DS:SI->disk address packet
   Exit:  CF=0 AH=0
          CF=1 AH=status
45 EDD lock/unlock drive
   Entry: DL=drive code
          AL=function (0=lock,1=unlock,2=status)
   Exit:  CF=0 AH=0
               AL=status (0=locked,1=unlocked)
          CF=1 AH=status
46 EDD eject media
   Entry: DL=drive code
          AL=0
   Exit:  CF=0 AH=0
          CF=1 AH=status
47 EDD extended seek
   Entry: DL=drive code
          DS:SI->disk address packet
   Exit:  CF=0 AH=0
          CF=1 AH=status
48 EDD extended get drive parameters
   Entry: DL=drive code
          DS:SI->buffer
   Exit:  CF=0 AH=0
          CF=1 AH=status
   Drive parameter table format:
    0 buffer size (minimum 26)
    2 flags
      Bit 0 1=DMA boundary errors handled by BIOS
          1 1=cylinder/head/sector per track info is valid
          2 1=removable drive
          3 1=verify write supported
          4 1=changeline supported
          5 1=drive can be locked
          6 1=cylinder/head/sector per track info is maximum per drive
    4 cylinders
    8 heads
   12 sectors per track
   16 total sectors
   24 sector size
   26 pointer to drive parameter table extension
       0 I/O port base address
       2 control port address
       4 value for head register
       5 reserved
       6 IRQ info (bits 0-3 IRQ number)
       7 sector count for read/write multiple
       8 DMA info (bits 4-7 DMA type,0-3 DMA channel)
       9 PIO info (bits 0-3 PIO type)
      10 option flags
         Bit 0 1=fast PIO access enabled
             1 1=fast DMA access enabled
             2 1=read/write multiple enabled
             3 1=CHS translation enabled
             4 1=LBA translation enabled
             5 1=removable media
             6 1=ATAPI device
             7 1=32-bit transfer mode enabled
             8 1=ATAPI device uses command packet interrupt
          9-10 translation type (0=bit-shift,1=LBA,2=reserved,3=vendor)
            11 1=ultra DMA access enabled
      12 reserved (0)
      14 table revision (11h)
      15 checksum
49 EDD get disk change status
   Entry: DL=drive code
   Exit:  CF=0 AH=0 changeline not active
          CF=1 AH=6 changeline active
4E EDD set hardware configuration
   Entry: DL=drive code
          AL=subfunction
             0=enable prefetch
             1=disable prefetch
             2=set maximum PIO mode
             3=set PIO mode 0
             4=set default PIO mode
             5=enable Int 13 DMA maximum mode
             6=disable Int 13 DMA
   Exit:  CF=0 AH=0
               AL=0 command was safe
               AL=1 other devices are affected
          CF=1 AH=status

INT 14 Serial port
00 Initialize serial port
   Entry: AL=parameter byte
             Bit 0-1 word length
                     10=7 bits,11=8 bits
                   2 stop bits
                     0=1 bit,1=2 bits
                 3-4 parity
                     x0=none,01=odd,11=even
                 5-7 baud rate
                     000=110  010=300  100=1200  110=4800
                     001=150  011=600  101=2400  111=9600
          DX=port number (0=COM1)
   Exit:  AH=port status
          AL=modem status
01 Write character
   Entry: AL=character
          DX=port number (0=COM1)
   Exit:  AH=port status
02 Read character
   Entry: DX=port number (0=COM1)
   Exit:  AH=port status
          AL=character
03 Get status
   Entry: DX=port number (0=COM1)
   Exit:  AH=port status
             Bit 0 1=data ready
                 1 1=overrun error
                 2 1=parity error
                 3 1=framing error
                 4 1=break detected
                 5 1=transmission hold register empty
                 6 1=transmission shift register empty
                 7 1=timed-out
          AL=modem status
             Bit 0 1=change in clear to send status
                 1 1=change in data set ready status
                 2 1=trailing edge ring indicator
                 3 1=change in receive line signal detected
                 4 1=clear to send
                 5 1=data set ready
                 6 1=ring indicator
                 7 1=receive line signal detected
04 Extended initialize (PS/2 and later systems)
   Entry: AL=break (0=no break,1=break)
          BH=parity
             0=none
             1=odd
             2=even
             3=stick parity odd
             4=stick parity even
          BL=stop bits
             0=1 bit
             1=2 bits (1.5 bits if CH=0)
          CH=word length
             0=5 bits  2=7 bits
             1=6 bits  3=8 bits
          CL=baud rate
             0=110  2=300  4=1200  6=4800  8=19200
             1=150  3=600  5=2400  7=9600
          DX=port number (0=COM1)
   Exit:  AH=port status
          AL=modem status
05 Extended communications port control (PS/2 and later systems)
   Entry: AL=function (0=read,1=write)
          BL=modem control register bits if AL=1
          DX=port number (0=COM1)
   Exit:  AH=port status
          AL=modem status
          BL=modem control register bits if AL=0

INT 15 System services
21 POST error log (PS/2 systems only)
   Entry: AL=0 read POST error log
          AL=1 write POST error log
          BH=device code if AL=1
          BL=error code if AL=1
   Exit:  CF=0 successful
               BX=number of POST codes in error log if AL=0
               ES:DI=pointer to POST error log if AL=0
          CF=1 error occurred
24 A20 support (later PS/2 systems only)
   Entry: AL=0 disable A20
          AL=1 enable A20
          AL=2 query A20 state
          AL=3 query A20 support
   Exit:  CF=0 successful
               AL=A20 state if AL=2
               BX=A20 support flags (0001=8042,0002=port 92) if AL=3
   Exit:  CF=1 error
41 Wait for external event
   Entry: AL=event code
             00=return after any event
             01,11=compare values, return if equal
             02,12=compare values, return if not equal
             03,13=test bit, return if set
             04,14=test bit, return if clear
          BH=compare or test value
          BL=timeout value in milliseconds (0=no timeout)
          ES:DI->byte for compare or test (01-04)
          DX=I/O port for compare or test (11-14)
4F Keyboard intercept
   Entry: CF=1, AL=scan code
   Exit:  AL=scan code
   Note:  This function is called by INT 9 for every keystroke.
          If the carry flag is cleared then the key will be ignored
          otherwise the scan code in AL will be used.
52 EDD media eject intercept
   Entry: DL=drive code
   Exit:  CF=0 AH=0 (allow eject)
          CF=1 AH=error code (disallow eject)
   Note:  This function is called by INT 13 function 46 to check if the
          eject media request is allowed.
53 Advanced Power Management (APM) functions
80 Device open
   Entry: BX=device ID
          CX=process ID
   Exit:  None
81 Device close
   Entry: BX=device ID
          CX=process ID
   Exit:  None
82 Device program terminate
   Entry: BX=device ID
   Exit:  None
83 Event wait
   Entry: AL=0 set interval
          AL=1 clear interval
          ES:BX->byte to post if AL=0
          CX:DX=interval in microseconds if AL=0
   Exit:  CF=0 function successful
          CF=1 wait in progress
   Note:  Bit 7 of the specified byte is set when the interval expires.
84 Read joystick
   Entry: DX=0 read switch settings
          DX=1 read resistive inputs
   Exit:  CF=0 (DX=0) AL=switch settings (bits 4-7)
               (DX=1) AX=A(x)
                      BX=A(y)
                      CX=B(x)
                      DX=B(y)
          CF=1 error occurred
85 SysReq
   Entry: AL=0 SysReq make
          AL=1 SysReq break
   Exit:  None
86 Wait
   Entry: CX:DX=interval in microseconds
   Exit:  CF=0 function successful
          CF=1 wait in progress
87 Move block
   Entry: CX=block size in words (maximum 32K)
          ES:SI->global descriptor table (GDT)
                 dummy descriptor
                 GDT descriptor (set by BIOS)
                 source block descriptor
                 target block descriptor
                 CS descriptor (set by BIOS)
                 SS descriptor (set by BIOS)
   Exit:  CF=0 AH=0 successful
          CF=1 AH=1 parity error
               AH=2 exception interrupt
               AH=3 gate A20 failed
88 Get extended memory size <64M
   Entry: None
   Exit:  AX=extended memory size in kilobytes
89 Enter protected mode
   Entry: BH=IDT index for IRQ 0-7
          BL=IDT index for IRQ 8-15
          ES:SI->global descriptor table (GDT)
                 dummy descriptor
                 GDT descriptor
                 IDT descriptor
                 DS descriptor
                 ES descriptor
                 SS descriptor
                 CS descriptor
                 BIOS CS descriptor (set by BIOS)
   Exit:  AH=00 successful
          AH=FF error occurred
   Note:  The code to execute in protected mode should immediately
          follow the INT 15 function 89 call.
90 Device busy (wait)
   Entry: AL=device type
             00=fixed disk (time-out)
             01=floppy disk (time-out)
             02=keyboard (no time-out)
             03=PS/2 mouse (time-out)
             80=network (no time-out)
             FC=PS/2 fixed disk reset (time-out, no post call)
             FD=floppy drive motor start (time-out, no post call)
             FE=printer (time-out, no post call)
          ES:BX->network control block if AL=80
   Exit:  CF=0 wait time not satisfied
          CF=1 wait time satisfied
   Note:  This function is called by the BIOS to allow a multitasking
          dispatcher to start another task.
91 Interrupt complete (post)
   Entry: AL=device type (same as function 90)
          ES:BX->network control block if AL=80
   Exit:  None
   Note:  This function is called by the BIOS to allow a multitasking
          dispatcher to start a previously suspended task.
C0 Get system parameters
   Entry: None
   Exit:  ES:BX->system descriptor table
                 0 table size (8 bytes)
                 2 system model byte
                   FF=PC
                   FE=XT
                   FD=PCjr
                   FC=AT,286-based PS/2 systems and most others
                   FB=later XT
                   FA=8086-based PS/2 systems
                   F9=PC Convertible
                   F8=386/486/Pentium-based PS/2 systems
                 3 system submodel byte
                 4 BIOS revision level
                 5 feature info 1
                   Bit 0 reserved
                       1 1=MCA bus
                       2 1=extended BIOS data area present
                       3 1=wait for external event supported
                       4 1=keyboard intercept supported
                       5 1=real-time clock present
                       6 1=second interrupt controller present
                       7 1=DMA channel 3 used by BIOS
                 6 reserved (4 bytes)
C1 Return extended BIOS data area segment (PS/2 and later systems)
   Entry: None
   Exit:  ES=extended BIOS data area segment
C2 Pointing device (PS/2 and later systems)
   00 Enable/disable pointing device
      Entry: BH=0 disable
             BH=1 enable
      Exit:  CF=0 AH=0
             CF=1 AH=status
   01 Reset pointing device
      Entry: None
      Exit:  CF=0 AH=0
                  BH=device ID
                  BL=device value (AA=mouse)
             CF=1 AH=status
   02 Set sample rate
      Entry: BH=sample rate value (reports per second)
                0=10  1=20  2=40  3=60  4=80  5=100  6=200
      Exit:  CF=0 AH=0
             CF=1 AH=status
   03 Set resolution
      Entry: BH=resolution value (counts per millimeter)
                0=1  1=2  2=4  3=8
      Exit:  CF=0 AH=0
             CF=1 AH=status
   04 Read device type
      Entry: None
      Exit:  CF=0 AH=0
                  BH=device ID
             CF=1 AH=status
   05 Pointing device interface init
      Entry: BH=data package size (1-8)
      Exit:  CF=0 AH=0
             CF=1 AH=status
   06 Extended commands
      Entry: BH=0 return status
             BH=1 set scaling to 1:1
             BH=2 set scaling to 2:1
      Exit:  CF=0 AH=0
                  BL=status byte 1 if BH=0
                  CL=status byte 2 if BH=0
                  DL=status byte 3 if BH=0
             CF=1 AH=status
   07 Device driver farcall init
      Entry: ES:BX=farcall routine address (0=remove)
      Exit:  CF=0 AH=0
             CF=1 AH=status
      Note:  The farcall routine is called with the following stack parameters
             word 1: status
                     Bit 0 1=left button pressed
                         1 1=right button pressed
                         2 reserved (0)
                         3 reserved (1)
                         4 1=X data negative
                         5 1=Y data negative
                         6 1=X data overflow
                         7 1=Y data overflow
             word 2: X data
             word 3: Y data
             word 4: 0
C3 Enable/disable watchdog timer (PS/2 systems only)
   Entry: AL=0 disable watchdog timer
          AL=1 enable watchdog timer
          BX=watchdog timer count (1-255) if AL=1
   Exit:  CF=0 successful
          CF=1 error occurred
   Note:  The watchdog timer uses a counter of a second 8254 timer which
          is connected to IRQ0
C4 Programmable option select (PS/2 systems only)
   Entry: AL=function
             0=return base POS adapter register address
             1=enable slot for setup
             2=disable setup for all slots (enable adapter)
          BL=slot number if AL=1
   Exit:  CF=0 successful
               DX=base POS adapter register address if AL=0
          CF=1 error occurred
C7 Return memory map info (later PS/2 systems only)
   Entry: DS:SI->buffer for memory map info
   Exit:  CF=0 successful
          CF=1 error occurred
   Memory map data:
    0 table length excluding this word
    2 local memory between 1M and 16M in 1K blocks
    6 local memory between 16M and 4G in 1K blocks
   10 system memory between 1M and 16M in 1K blocks
   14 system memory between 16M and 4G in 1K blocks
   18 cacheable memory between 1M and 16M in 1K blocks
   22 cacheable memory between 16M and 4G in 1K blocks
   26 1K blocks before start of non-system memory between 1M and 16M
   30 1K blocks before start of non-system memory between 16M and 4G
   34 start segment of largest free block between C0000 and DFFFF
   36 size of largest free block between C0000 and DFFFF
D800 EISA read slot configuration information
   Entry: CL=slot number
   Exit:  CF=0 AH=0
               AL=vendor information byte
                  Bits 0-3 duplicate ID number if bit 7 set
                         4 1=product ID readable
                       5-6 slot type
                           00=expansion slot
                           01=embedded device
                           10=virtual device
                           11=reserved
                         7 1=duplicate IDs
               BH=configuration utility major revision level
               BL=configuration utility minor revision level
               CX=checksum of configuration file
               DH=number of device functions
               DL=function information byte
                  Bit 0 1=slot has function type entries
                      1 1=slot has memory entries
                      2 1=slot has IRQ entries
                      3 1=slot has DMA entries
                      4 1=slot has port range entries
                      5 1=slot has port initialization entries
                      6 1=slot has free form data entries
                      7 reserved
               SI:DI=compressed device ID
          CF=1 AH=status
                  80 invalid slot number
                  81 invalid function number
                  82 EISA CMOS corrupted
                  83 empty slot
                  84 error writing EISA CMOS
                  85 EISA CMOS full
                  86 invalid BIOS function call
                  87 invalid system configuration
                  88 configuration utility not supported
D801 EISA read function configuration information
   Entry: CH=function number
          CL=slot number
          DS:SI->buffer
   Exit:  CF=0 AH=0
          CF=1 AH=status
D802 EISA clear CMOS configuration
   Entry: BH=configuration utility major revision level
          BL=configuration utility minor revision level
   Exit:  CF=0 AH=0
          CF=1 AH=status
D803 EISA write slot configuration information
   Entry: CX=data length
          DS:SI->buffer
   Exit:  CF=0 AH=0
          CF=1 AH=status
D804 EISA read board ID registers
   Entry: CL=slot number
   Exit:  CF=0 AH=0
               SI:DI=compressed device ID
          CF=1 AH=status
E801 Get extended memory size >64M
   Entry: None
   Exit:  CF=0 successful
               AX=extended memory between 1M and 16M in kilobytes
               BX=extended memory above 16M in 64K blocks
               CX=configured memory 1M to 16M in kilobytes
               DX=configured memory above 16M in 64K blocks
          CF=1 error occurred
E820 Get system memory map
   Entry: EAX=0000E820
          EBX=continuation value or 0
          ECX=buffer size (should be 20)
          EDX=534D4150 ('SMAP')
          ES:DI->buffer for memory map array
   Exit:  CF=0 successful
               EBX=continuation value or 0
               ECX=returned data size
          CF=1 error occurred
   Memory map data:
    0 base address
    8 length in bytes
   16 address range type (1=memory,2=reserved,3=ACPI reclaim,4=ACPI NVS)

INT 16 Keyboard
00 Read character
   Entry: None
   Exit:  AH=scan code
          AL=character
01 Read status
   Entry: None
   Exit:  ZF=0 AH=scan code
               AL=character
          ZF=1 no key waiting
02 Get keyboard flags
   Entry: None
   Exit:  AL=keyboard flags
             Bit 0 1=right Shift key down
                 1 1=left Shift key down
                 2 1=Ctrl key down
                 3 1=Alt key down
                 4 1=Scroll Lock on
                 5 1=Num Lock on
                 6 1=Caps Lock on
                 7 1=Insert on
03 Set typematic rate/delay
   Entry: AL=05
          BH=typematic delay (0=250ms,1=500ms,2=750ms,3=1000ms)
          BL=typematic rate (00-1F: 00=fastest 0B=default 1F=slowest)
   Exit:  None
05 Write to keyboard buffer
   Entry: CH=scan code
          CL=character
   Exit:  AL=0 character written
          AL=1 buffer full
10 Read character extended
   Entry: None
   Exit:  Same as function 00
11 Read status extended
   Entry: None
   Exit:  Same as function 01
12 Get keyboard flags extended
   Entry: None
   Exit:  AL=keyboard flags
             Bit 0 1=right Shift key down
                 1 1=left Shift key down
                 2 1=Ctrl key down
                 3 1=Alt key down
                 4 1=Scroll Lock on
                 5 1=Num Lock on
                 6 1=Caps Lock on
                 7 1=Insert on
          AH=extended keyboard flags
             Bit 0 1=left Ctrl key down
                 1 1=left Alt key down
                 2 1=right Ctrl key down
                 3 1=right Alt key down
                 4 1=Scroll Lock down
                 5 1=Num Lock down
                 6 1=Caps Lock down
                 7 1=SysReq key down

INT 17 Printer
00 Write character
   Entry: AL=character
          DX=printer number (0=LPT1)
   Exit:  AH=printer status
01 Initialize printer port
   Entry: DX=printer number (0=LPT1)
   Exit:  AH=printer status
02 Get status
   Entry: DX=printer number (0=LPT1)
   Exit:  AH=printer status
             Bit 0 1=timed-out
               1-2 reserved
                 3 1=output error
                 4 1=printer selected
                 5 1=out of paper
                 6 1=acknowledge
                 7 1=printer not busy

INT 18 Diskless boot
       This interrupt is issued when no boot device is found and starts
       ROM BASIC on older IBM systems.

INT 19 Reboot
       Issuing this interrupt performs a warm start of the computer by
       reading the first sector of the first disk found into location
       0:7C00 and executing the boot code with DL set to the drive code.

INT 1A Time of day
00 Get clock
   Entry: None
   Exit:  AL=timer overflow flag
          CX=high part of timer count
          DX=low part of timer count
01 Set clock
   Entry: CX=high part of timer count
          DX=low part of timer count
   Exit:  None
02 Read real-time clock time
   Entry: None
   Exit:  CH=hours (BCD)
          CL=minutes (BCD)
          DH=seconds (BCD)
          DL=daylight savings time flag (1=enabled)
03 Set real-time clock time
   Entry: CH=hours (BCD)
          CL=minutes (BCD)
          DH=seconds (BCD)
          DL=daylight savings time flag (1=enabled)
   Exit:  None
04 Read real-time clock date
   Entry: None
   Exit:  CX=year (BCD)
          DH=month (BCD)
          DL=day (BCD)
05 Set real-time clock date
   Entry: CX=year (BCD)
          DH=month (BCD)
          DL=day (BCD)
   Exit:  None
06 Set alarm
   Entry: CH=hours (BCD)
          CL=minutes (BCD)
          DH=seconds (BCD)
   Exit:  CF=0 alarm set
          CF=1 alarm already set
   Notes: 1) The alarm is issued via INT 4A.
          2) If -1 is specified for a value then that position is ignored.
07 Reset alarm
   Entry: None
   Exit:  None

INT 1A PCI BIOS
Note: PCI BIOS functions can modify EAX,EBX,ECX,EDX and may use up to
      1024 bytes of stack space.
B101 Installation check
   Entry: EDI=0
   Exit:  CF=0 AH=0
               AL=PCI hardware characteristics
                  Bit 0 configuration space access mechanism 1 supported
                      1 configuration space access mechanism 2 supported
                    2-3 reserved
                      4 special cycle generation mechanism 1 supported
                      5 special cycle generation mechanism 2 supported
                    6-7 reserved
               BH=PCI major version
               BL=PCI minor version
               CL=number of last PCI bus
               EDX=20494350 ('PCI ')
               EDI=protected mode entry point physical address
          CF=1 AH=status
                  81 unsupported function
                  83 bad vendor ID
                  86 device ID not found
                  87 bad register number
                  88 set failed
                  89 buffer too small
B102 Find PCI device
   Entry: CX=device ID
          DX=vendor ID
          SI=device index
   Exit:  CF=0 AH=0
               BH=bus number
               BL=device/function number (bits 3-7 device,0-2 function)
          CF=1 AH=status
B103 Find PCI class code
   Entry: ECX=class code
              bits 0-7 programming interface
                  8-15 subclass
                 16-23 class
                 24-31 unused
          SI=device index
   Exit:  CF=0 AH=0
               BH=bus number
               BL=device/function number
          CF=1 AH=status
B106 PCI bus-specific operations
   Entry: BH=bus number
          EDX=special cycle data
   Exit:  CF=0 AH=0
          CF=1 AH=status
B108 Read configuration byte
   Entry: BH=bus number
          BL=device/function number
          DI=register number
   Exit:  CF=0 AH=0
               CL=byte read
          CF=1 AH=status
B109 Read configuration word
   Entry: BH=bus number
          BL=device/function number
          DI=register number
   Exit:  CF=0 AH=0
               CX=word read
          CF=1 AH=status
B10A Read configuration dword
   Entry: BH=bus number
          BL=device/function number
          DI=register number
   Exit:  CF=0 AH=0
               ECX=dword read
          CF=1 AH=status
B10B Write configuration byte
   Entry: BH=bus number
          BL=device/function number
          CL=byte to write
          DI=register number
   Exit:  CF=0 AH=0
          CF=1 AH=status
B10C Write configuration word
   Entry: BH=bus number
          BL=device/function number
          CX=word to write
          DI=register number
   Exit:  CF=0 AH=0
          CF=1 AH=status
B10D Write configuration dword
   Entry: BH=bus number
          BL=device/function number
          ECX=dword to write
          DI=register number
   Exit:  CF=0 AH=0
          CF=1 AH=status
B10E Get IRQ routing info
   Entry: BX=0
          DS=F000
          ES:DI->IRQ routing header
                 0 length of IRQ routing table buffer
                 2 pointer to IRQ routing table array
   Exit:  CF=0 AH=0
               BX=PCI IRQ bitmap
          CF=1 AH=status
   IRQ routing table entry format:
    0 PCI bus number
    1 PCI device number (bits 3-7)
    2 INTA link value
    3 INTA IRQ connectivity bitmap
    5 INTB link value
    6 INTB IRQ connectivity bitmap
    8 INTC link value
   10 INTC IRQ connectivity bitmap
   12 INTD link value
   13 INTD IRQ connectivity bitmap
   14 device slot number (0=motherboard)
   15 reserved
B10F Set PCI IRQ
   Entry: BH=bus number
          BL=device/function number
          CH=IRQ number to connect
          CL=interrupt pin number (0A-0D)
          DS=F000
   Exit:  CF=0 AH=0
          CF=1 AH=status

INT 1B Ctrl-Break
       This interrupt is issued by INT 9 when Ctrl-Break is pressed
       to execute an optional Ctrl-Break handler.

INT 1C Timer tick
       This interrupt is issued by INT 8 to execute an optional
       timer-dependent routine.

INT 4A Alarm
       This interrupt is issued when the specified alarm time
       (set via INT 1A function 06) is reached.

INT 70 Real-time clock (IRQ 8)
       This interrupt is issued 1024 times per second and is responsible
       for updating the wait count (set via INT 15 function 83 or 86) and
       issuing INT 4A when the CMOS alarm time is reached.

INT 71 Redirect (IRQ 9)
       This interrupt is normally redirected to INT 0A (IRQ 2).

INT 72 Unused (IRQ 10)

INT 73 Unused (IRQ 11)

INT 74 PS/2 mouse or unused (IRQ 12)

INT 75 Coprocessor (IRQ 13)
       This interrupt is issued for coprocessor errors and is normally
       redirected to NMI (INT 2).

INT 76 Primary IDE or fixed disk (IRQ 14)
       This interrupt is issued upon fixed disk or IDE I/O completion and
       is responsible for updating the fixed disk interrupt flag at 40:8E.

INT 77 Secondary IDE or unused (IRQ 15)
       This interrupt is issued upon IDE I/O completion.
