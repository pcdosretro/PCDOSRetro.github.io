   00 /r	   ADD		r/m8,r8							Add
   01 /r	   ADD		r/m16/32,r16/32						Add
   02 /r	   ADD		r8,r/m8							Add
   03 /r	   ADD		r16/32,r/m16/32						Add
   04 ib	   ADD		AL,i8							Add
   05 iw/id	   ADD		eAX,i16/32						Add
   06		   PUSH		ES							Push
   07		   POP		ES							Pop
   08 /r	   OR		r/m8,r8							OR
   09 /r	   OR		r/m16/32,r16/32						OR
   0A /r	   OR		r8,r/m8							OR
   0B /r	   OR		r16/32,r/m16/32						OR
   0C ib	   OR		AL,i8							OR
   0D iw/id	   OR		eAX,i16/32						OR
   0E		   PUSH		CS							Push
   0F		   ***					two-byte opcodes
   10 /r	   ADC		r/m8,r8							Add with Carry
   11 /r	   ADC		r/m16/32,r16/32						Add with Carry
   12 /r	   ADC		r8,r/m8							Add with Carry
   13 /r	   ADC		r16/32,r/m16/32						Add with Carry
   14 ib	   ADC		AL,i8							Add with Carry
   15 iw/id	   ADC		eAX,i16/32						Add with Carry
   16		   PUSH		SS							Push
   17		   POP		SS							Pop
   18 /r	   SBB		r/m8,r8							Subtract with Borrow
   19 /r	   SBB		r/m16/32,r16/32						Subtract with Borrow
   1A /r	   SBB		r8,r/m8							Subtract with Borrow
   1B /r	   SBB		r16/32,r/m16/32						Subtract with Borrow
   1C ib	   SBB		AL,i8							Subtract with Borrow
   1D iw/id	   SBB		eAX,i16/32						Subtract with Borrow
   1E		   PUSH		DS							Push
   1F		   POP		DS							Pop
   20 /r	   AND		r/m8,r8							AND
   21 /r	   AND		r/m16/32,r16/32						AND
   22 /r	   AND		r8,r/m8							AND
   23 /r	   AND		r16/32,r/m16/32						AND
   24 ib	   AND		AL,i8							AND
   25 iw/id	   AND		eAX,i16/32						AND
   26		   ES:									Segment	Override Prefix
   27		   DAA									Decimal	Adjust After Addition
   28 /r	   SUB		r/m8,r8							Subtract
   29 /r	   SUB		r/m16/32,r16/32						Subtract
   2A /r	   SUB		r8,r/m8							Subtract
   2B /r	   SUB		r16/32,r/m16/32						Subtract
   2C ib	   SUB		AL,i8							Subtract
   2D iw/id	   SUB		eAX,i16/32						Subtract
   2E		   CS:									Segment	Override Prefix
   2F		   DAS									Decimal	Adjust After Subtraction
   30 /r	   XOR		r/m8,r8							XOR
   31 /r	   XOR		r/m16/32,r16/32						XOR
   32 /r	   XOR		r8,r/m8							XOR
   33 /r	   XOR		r16/32,r/m16/32						XOR
   34 ib	   XOR		AL,i8							XOR
   35 iw/id	   XOR		eAX,i16/32						XOR
   36		   SS:									Segment	Override Prefix
   37		   AAA									ASCII Adjust After Addition
   38 /r	   CMP		r/m8,r8							Compare
   39 /r	   CMP		r/m16/32,r16/32						Compare
   3A /r	   CMP		r8,r/m8							Compare
   3B /r	   CMP		r16/32,r/m16/32						Compare
   3C ib	   CMP		AL,i8							Compare
   3D iw/id	   CMP		eAX,i16/32						Compare
   3E		   DS:									Segment	Override Prefix
   3F		   AAS									ASCII Adjust After Subtraction
   40		   INC		eAX							Increment
   41		   INC		eCX							Increment
   42		   INC		eDX							Increment
   43		   INC		eBX							Increment
   44		   INC		eSP							Increment
   45		   INC		eBP							Increment
   46		   INC		eSI							Increment
   47		   INC		eDI							Increment
   48		   DEC		eAX							Decrement
   49		   DEC		eCX							Decrement
   4A		   DEC		eDX							Decrement
   4B		   DEC		eBX							Decrement
   4C		   DEC		eSP							Decrement
   4D		   DEC		eBP							Decrement
   4E		   DEC		eSI							Decrement
   4F		   DEC		eDI							Decrement
   50		   PUSH		eAX							Push
   51		   PUSH		eCX							Push
   52		   PUSH		eDX							Push
   53		   PUSH		eBX							Push
   54		   PUSH		eSP							Push
   55		   PUSH		eBP							Push
   56		   PUSH		eSI							Push
   57		   PUSH		eDI							Push
   58		   POP		eAX							Pop
   59		   POP		eCX							Pop
   5A		   POP		eDX							Pop
   5B		   POP		eBX							Pop
   5C		   POP		eSP							Pop
   5D		   POP		eBP							Pop
   5E		   POP		eSI							Pop
   5F		   POP		eDI							Pop
   60		   PUSHA				186+ PUSHAD if 32-bit		Push All Registers
   61		   POPA					186+ POPAD if 32-bit		Pop All	Registers
   62 /r	   BOUND	r16/32,m16/32&16/32	186+				Check Array Index Against Bounds
   63 /r	   ARPL		r/m16,r16		286+				Adjust RPL Field of Segment Selector
   64		   FS:					386+				Segment	Override Prefix
   65		   GS:					386+				Segment	Override Prefix
   66		   opsize				386+				Operand	Size Override Prefix
   67		   adsize				386+				Address	Size Override Prefix
   68 iw/id	   PUSH		i16/32			186+				Push
   69 /r iw/id	   IMUL		r16/32,r/m16/32,i16/32	186+				Signed Multiply
   6A ib	   PUSH		i8			186+ i8	is sign-extended	Push
   6B /r ib	   IMUL		r16/32,r/m16/32,i8	186+ i8	is sign-extended	Signed Multiply
   6C		   INSB					186+				Input from Port	to String
   6D		   INSW					186+ INSD if 32-bit		Input from Port	to String
   6E		   OUTSB				186+				Output to Port from String
   6F		   OUTSW				186+ OUTSD if 32-bit		Output to Port from String
   70 rel	   JO		rel8							Jump if	Overflow
   71 rel	   JNO		rel8							Jump if	Not Overflow
   72 rel	   JC		rel8			also JB	and JNAE		Jump if	Carry
   73 rel	   JNC		rel8			also JAE and JNB		Jump if	Not Carry
   74 rel	   JZ		rel8			also JE				Jump if	Zero
   75 rel	   JNZ		rel8			also JNE			Jump if	Not Zero
   76 rel	   JBE		rel8			also JNA			Jump if	Below or Equal
   77 rel	   JA		rel8			also JNBE			Jump if	Above
   78 rel	   JS		rel8							Jump if	Sign
   79 rel	   JNS		rel8							Jump if	Not Sign
   7A rel	   JP		rel8			also JPE			Jump if	Parity
   7B rel	   JNP		rel8			also JPO			Jump if	Not Parity
   7C rel	   JL		rel8			also JNGE			Jump if	Less Than
   7D rel	   JGE		rel8			also JNL			Jump if	Greater	Than or	Equal
   7E rel	   JLE		rel8			also JNG			Jump if	Less Than or Equal
   7F rel	   JG		rel8			also JNLE			Jump if	Greater	Than
   80 /0 ib	   ADD		r/m8,i8							Add
   80 /1 ib	   OR		r/m8,i8							OR
   80 /2 ib	   ADC		r/m8,i8							Add with Carry
   80 /3 ib	   SBB		r/m8,i8							Subtract with Borrow
   80 /4 ib	   AND		r/m8,i8							AND
   80 /5 ib	   SUB		r/m8,i8							Subtract
   80 /6 ib	   XOR		r/m8,i8							XOR
   80 /7 ib	   CMP		r/m8,i8							Compare
   81 /0 iw/id	   ADD		r/m16/32,i16/32						Add
   81 /1 iw/id	   OR		r/m16/32,i16/32						OR
   81 /2 iw/id	   ADC		r/m16/32,i16/32						Add with Carry
   81 /3 iw/id	   SBB		r/m16/32,i16/32						Subtract with Borrow
   81 /4 iw/id	   AND		r/m16/32,i16/32						AND
   81 /5 iw/id	   SUB		r/m16/32,i16/32						Subtract
   81 /6 iw/id	   XOR		r/m16/32,i16/32						XOR
   81 /7 iw/id	   CMP		r/m16/32,i16/32						Compare
   82 /0 ib	   ADD		r/m8,i8			undocumented, same as 80	Add
   82 /1 ib	   OR		r/m8,i8			undocumented, same as 80	OR
   82 /2 ib	   ADC		r/m8,i8			undocumented, same as 80	Add with Carry
   82 /3 ib	   SBB		r/m8,i8			undocumented, same as 80	Subtract with Borrow
   82 /4 ib	   AND		r/m8,i8			undocumented, same as 80	AND
   82 /5 ib	   SUB		r/m8,i8			undocumented, same as 80	Subtract
   82 /6 ib	   XOR		r/m8,i8			undocumented, same as 80	XOR
   82 /7 ib	   CMP		r/m8,i8			undocumented, same as 80	Compare
   83 /0 ib	   ADD		r/m16/32,i8		i8 is sign-extended		Add
   83 /1 ib	   OR		r/m16/32,i8		i8 is sign-extended		OR
   83 /2 ib	   ADC		r/m16/32,i8		i8 is sign-extended		Add with Carry
   83 /3 ib	   SBB		r/m16/32,i8		i8 is sign-extended		Subtract with Borrow
   83 /4 ib	   AND		r/m16/32,i8		i8 is sign-extended		AND
   83 /5 ib	   SUB		r/m16/32,i8		i8 is sign-extended		Subtract
   83 /6 ib	   XOR		r/m16/32,i8		i8 is sign-extended		XOR
   83 /7 ib	   CMP		r/m16/32,i8		i8 is sign-extended		Compare
   84 /r	   TEST		r/m8,r8							Test
   85 /r	   TEST		r/m16/32,r16/32						Test
   86 /r	   XCHG		r/m8,r8							Exchange
   87 /r	   XCHG		r/m16/32,r16/32						Exchange
   88 /r	   MOV		r/m8,r8							Move
   89 /r	   MOV		r/m16/32,r16/32						Move
   8A /r	   MOV		r8,r/m8							Move
   8B /r	   MOV		r16/32,r/m16/32						Move
   8C /s	   MOV		r/m16,sreg						Move
   8D /r	   LEA		r16/32,m						Load Effective Address
   8E /s	   MOV		sreg,r/m16						Move
   8F /0	   POP		m16/32							Pop
   90		   XCHG		eAX,eAX			also NOP			No Operation
F3 90		   PAUSE				SSE2				Spin Loop Hint
   91		   XCHG		eAX,eCX							Exchange
   92		   XCHG		eAX,eDX							Exchange
   93		   XCHG		eAX,eBX							Exchange
   94		   XCHG		eAX,eSP							Exchange
   95		   XCHG		eAX,eBP							Exchange
   96		   XCHG		eAX,eSI							Exchange
   97		   XCHG		eAX,eDI							Exchange
   98		   CBW					CWDE if	32-bit			Convert	Byte to	Word/Convert Word to Doubleword
   99		   CWD					CDQ if 32-bit			Convert	Word to	Doubleword/Convert Doubleword to Quadword
   9A ptr	   CALL		ptr16:16/32						Call
   9B		   WAIT					also FWAIT			Wait
   9C		   PUSHF				PUSHFD if 32-bit		Push Flags
   9D		   POPF					POPFD if 32-bit			Pop Flags
   9E		   SAHF									Store AH into Flags
   9F		   LAHF									Load AH	from Flags
   A0 off	   MOV		AL,moff8						Move
   A1 off	   MOV		eAX,moff16/32						Move
   A2 off	   MOV		moff8,AL						Move
   A3 off	   MOV		moff16/32,eAX						Move
   A4		   MOVSB								Move String
   A5		   MOVSW				MOVSD if 32-bit			Move String
   A6		   CMPSB								Compare	String
   A7		   CMPSW				CMPSD if 32-bit			Compare	String
   A8 ib	   TEST		AL,i8							Test
   A9 iw/id	   TEST		eAX,i16/32						Test
   AA		   STOSB								Store String
   AB		   STOSW				STOSD if 32-bit			Store String
   AC		   LODSB								Load String
   AD		   LODSW				LODSD if 32-bit			Load String
   AE		   SCASB								Scan String
   AF		   SCASW				SCASD if 32-bit			Scan String
   B0 ib	   MOV		AL,i8							Move
   B1 ib	   MOV		CL,i8							Move
   B2 ib	   MOV		DL,i8							Move
   B3 ib	   MOV		BL,i8							Move
   B4 ib	   MOV		AH,i8							Move
   B5 ib	   MOV		CH,i8							Move
   B6 ib	   MOV		DH,i8							Move
   B7 ib	   MOV		BH,i8							Move
   B8 iw/id	   MOV		eAX,i16/32						Move
   B9 iw/id	   MOV		eCX,i16/32						Move
   BA iw/id	   MOV		eDX,i16/32						Move
   BB iw/id	   MOV		eBX,i16/32						Move
   BC iw/id	   MOV		eSP,i16/32						Move
   BD iw/id	   MOV		eBP,i16/32						Move
   BE iw/id	   MOV		eSI,i16/32						Move
   BF iw/id	   MOV		eDI,i16/32						Move
   C0 /0 ib	   ROL		r/m8,i8			186+				Rotate Left
   C0 /1 ib	   ROR		r/m8,i8			186+				Rotate Right
   C0 /2 ib	   RCL		r/m8,i8			186+				Rotate Left with Carry
   C0 /3 ib	   RCR		r/m8,i8			186+				Rotate Right with Carry
   C0 /4 ib	   SHL		r/m8,i8			186+				Shift Left
   C0 /5 ib	   SHR		r/m8,i8			186+				Shift Right
   C0 /6 ib	   SAL		r/m8,i8			186+ undocumented, same	as /4	Shift Arithmetic Left
   C0 /7 ib	   SAR		r/m8,i8			186+				Shift Arithmetic Right
   C1 /0 ib	   ROL		r/m16/32,i8		186+				Rotate Left
   C1 /1 ib	   ROR		r/m16/32,i8		186+				Rotate Right
   C1 /2 ib	   RCL		r/m16/32,i8		186+				Rotate Left with Carry
   C1 /3 ib	   RCR		r/m16/32,i8		186+				Rotate Right with Carry
   C1 /4 ib	   SHL		r/m16/32,i8		186+				Shift Left
   C1 /5 ib	   SHR		r/m16/32,i8		186+				Shift Right
   C1 /6 ib	   SAL		r/m16/32,i8		186+ undocumented, same	as /4	Shift Arithmetic Left
   C1 /7 ib	   SAR		r/m16/32,i8		186+				Shift Arithmetic Right
   C2 iw	   RET		i16			also RETN			Return
   C3		   RET					also RETN			Return
   C4 /r	   LES		r16/32,m16:16/32					Load Far Pointer
   C5 /r	   LDS		r16/32,m16:16/32					Load Far Pointer
   C6 /0 ib	   MOV		r/m8,i8							Move
   C7 /0 iw/id	   MOV		r/m16/32,i16/32						Move
   C8 iw ib	   ENTER	i16,i8			186+				Create Stack Frame for Entering	Procedure
   C9		   LEAVE				186+				Release	Stack Frame for	Leaving	Procedure
   CA iw	   RETF		i16							Return Far
   CB		   RETF									Return Far
   CC		   INT		3							Interrupt
   CD ib	   INT		i8							Interrupt
   CE		   INTO									Interrupt if Overflow
   CF		   IRET					IRETD if 32-bit			Interrupt Return
   D0 /0	   ROL		r/m8,1							Rotate Left
   D0 /1	   ROR		r/m8,1							Rotate Right
   D0 /2	   RCL		r/m8,1							Rotate Left with Carry
   D0 /3	   RCR		r/m8,1							Rotate Right with Carry
   D0 /4	   SHL		r/m8,1							Shift Left
   D0 /5	   SHR		r/m8,1							Shift Right
   D0 /6	   SAL		r/m8,1			undocumented, same as /4	Shift Arithmetic Left
   D0 /7	   SAR		r/m8,1							Shift Arithmetic Right
   D1 /0	   ROL		r/m16/32,1						Rotate Left
   D1 /1	   ROR		r/m16/32,1						Rotate Right
   D1 /2	   RCL		r/m16/32,1						Rotate Left with Carry
   D1 /3	   RCR		r/m16/32,1						Rotate Right with Carry
   D1 /4	   SHL		r/m16/32,1						Shift Left
   D1 /5	   SHR		r/m16/32,1						Shift Right
   D1 /6	   SAL		r/m16/32,1		undocumented, same as /4	Shift Arithmetic Left
   D1 /7	   SAR		r/m16/32,1						Shift Arithmetic Right
   D2 /0	   ROL		r/m8,CL							Rotate Left
   D2 /1	   ROR		r/m8,CL							Rotate Right
   D2 /2	   RCL		r/m8,CL							Rotate Left with Carry
   D2 /3	   RCR		r/m8,CL							Rotate Right with Carry
   D2 /4	   SHL		r/m8,CL							Shift Left
   D2 /5	   SHR		r/m8,CL							Shift Right
   D2 /6	   SAL		r/m8,CL			undocumented, same as /4	Shift Arithmetic Left
   D2 /7	   SAR		r/m8,CL							Shift Arithmetic Right
   D3 /0	   ROL		r/m16/32,CL						Rotate Left
   D3 /1	   ROR		r/m16/32,CL						Rotate Right
   D3 /2	   RCL		r/m16/32,CL						Rotate Left with Carry
   D3 /3	   RCR		r/m16/32,CL						Rotate Right with Carry
   D3 /4	   SHL		r/m16/32,CL						Shift Left
   D3 /5	   SHR		r/m16/32,CL						Shift Right
   D3 /6	   SAL		r/m16/32,CL		undocumented, same as /4	Shift Arithmetic Left
   D3 /7	   SAR		r/m16/32,CL						Shift Arithmetic Right
   D4 ib	   AAM		i8							ASCII Adjust After Multiplication
   D5 ib	   AAD		i8							ASCII Adjust Before Division
   D6		   SALC					undocumented			Set AL from Carry
   D7		   XLAT					also XLATB			Translate
   D8 /0	   FADD		m32							Add
   D8 /1	   FMUL		m32							Multiply
   D8 /2	   FCOM		m32							Compare
   D8 /3	   FCOMP	m32							Compare	and Pop
   D8 /4	   FSUB		m32							Subtract
   D8 /5	   FSUBR	m32							Reverse	Subtract
   D8 /6	   FDIV		m32							Divide
   D8 /7	   FDIVR	m32							Reverse	Divide
   D8 C0+i	   FADD		ST,ST(i)						Add
   D8 C8+i	   FMUL		ST,ST(i)						Multiply
   D8 D0+i	   FCOM		ST(i)			FCOM is	D8 D1			Compare
   D8 D8+i	   FCOMP	ST(i)			FCOMP is D8 D9			Compare	and Pop
   D8 E0+i	   FSUB		ST,ST(i)						Subtract
   D8 E8+i	   FSUBR	ST,ST(i)						Reverse	Subtract
   D8 F0+i	   FDIV		ST,ST(i)						Divide
   D8 F8+i	   FDIVR	ST,ST(i)						Reverse	Divide
   D9 /0	   FLD		m32							Load
   D9 /2	   FST		m32							Store
   D9 /3	   FSTP		m32							Store and Pop
   D9 /4	   FLDENV	m14/28							Load FPU Environment
   D9 /5	   FLDCW	m2							Load FPU Control Word
   D9 /6	   FSTENV	m14/28							Store FPU Environment
   D9 /7	   FSTCW	m2							Store FPU Control Word
   D9 C0+i	   FLD		ST(i)							Load
   D9 C8+i	   FXCH		ST(i)			FXCH is	D9 C9			Exchange
   D9 D0	   FNOP									No Operation
   D9 D8+i	   FSTP		ST(i)			undocumented duplicate		Store and Pop
   D9 E0	   FCHS									Change Sign
   D9 E1	   FABS									Absolute Value
   D9 E4	   FTST									Test
   D9 E5	   FXAM									Examine
   D9 E8	   FLD1									Load 1
   D9 E9	   FLDL2T								Load log2(10)
   D9 EA	   FLDL2E								Load log2(e)
   D9 EB	   FLDPI								Load pi
   D9 EC	   FLDLG2								Load log(2)
   D9 ED	   FLDLN2								Load ln(2)
   D9 EE	   FLDZ									Load 0
   D9 F0	   F2XM1								Compute	2^x-1
   D9 F1	   FYL2X								Compute	y*log2(x) and Pop
   D9 F2	   FPTAN								Partial	Tangent
   D9 F3	   FPATAN								Partial	Arctangent
   D9 F4	   FXTRACT								Extract	Exponent and Significand
   D9 F5	   FPREM1				387+				IEEE Partial Remainder
   D9 F6	   FDECSTP								Decrement Stack	Top Pointer
   D9 F7	   FINCSTP								Increment Stack	Top Pointer
   D9 F8	   FPREM								Partial	Remainder
   D9 F9	   FYL2XP1								Compute	y*log2(x+1) and	Pop
   D9 FA	   FSQRT								Square Root
   D9 FB	   FSINCOS				387+				Sine and Cosine
   D9 FC	   FRNDINT								Round to Integer
   D9 FD	   FSCALE								Scale
   D9 FE	   FSIN					387+				Sine
   D9 FF	   FCOS					387+				Cosine
   DA /0	   FIADD	m32							Integer	Add
   DA /1	   FIMUL	m32							Integer	Multiply
   DA /2	   FICOM	m32							Integer	Compare
   DA /3	   FICOMP	m32							Integer	Compare	and Pop
   DA /4	   FISUB	m32							Integer	Subtract
   DA /5	   FISUBR	m32							Integer	Reverse	Subtract
   DA /6	   FIDIV	m32							Integer	Divide
   DA /7	   FIDIVR	m32							Integer	Reverse	Divide
   DA C0+i	   FCMOVB	ST,ST(i)		P6+				Conditional Move if Below
   DA C8+i	   FCMOVE	ST,ST(i)		P6+				Conditional Move if Equal
   DA D0+i	   FCMOVBE	ST,ST(i)		P6+				Conditional Move if Below or Equal
   DA D8+i	   FCMOVU	ST,ST(i)		P6+				Conditional Move if Unordered
   DA E9	   FUCOMPP				387+				Unordered Compare and Pop Twice
   DB /0	   FILD		m32							Integer	Load
   DB /1	   FISTTP	m32			SSE3				Integer	Store with Truncation and Pop
   DB /2	   FIST		m32							Integer	Store
   DB /3	   FISTP	m32							Integer	Store and Pop
   DB /5	   FLD		m80							Load
   DB /7	   FSTP		m80							Store and Pop
   DB C0+i	   FCMOVNB	ST,ST(i)		P6+				Conditional Move if Not	Below
   DB C8+i	   FCMOVNE	ST,ST(i)		P6+				Conditional Move if Not	Equal
   DB D0+i	   FCMOVNBE	ST,ST(i)		P6+				Conditional Move if Not	Below or Equal
   DB D8+i	   FCMOVNU	ST,ST(i)		P6+				Conditional Move if Not	Unordered
   DB E0	   FENI					8087 only; FNOP	on 287+		Enable FPU Interrupts
   DB E1	   FDISI				8087 only; FNOP	on 287+		Disable	FPU Interrupts
   DB E2	   FCLEX								Clear Exceptions
   DB E3	   FINIT								FPU Initialize
   DB E4	   FSETPM				287 only; FNOP on 387+		FPU Set	Protected Mode
   DB E5	   FRSTPM				287XL only			FPU Reset Protected Mode
   DB E8+i	   FUCOMI	ST,ST(i)		P6+				Unordered Compare and Set EFLAGS
   DB F0+i	   FCOMI	ST,ST(i)		P6+				Compare	and Set	EFLAGS
   DC /0	   FADD		m64							Add
   DC /1	   FMUL		m64							Multiply
   DC /2	   FCOM		m64							Compare
   DC /3	   FCOMP	m64							Compare	and Pop
   DC /4	   FSUB		m64							Subtract
   DC /5	   FSUBR	m64							Reverse	Subtract
   DC /6	   FDIV		m64							Divide
   DC /7	   FDIVR	m64							Reverse	Divide
   DC C0+i	   FADD		ST(i),ST						Add
   DC C8+i	   FMUL		ST(i),ST						Multiply
   DC D0+i	   FCOM		ST(i)			undocumented duplicate		Compare
   DC D8+i	   FCOMP	ST(i)			undocumented duplicate		Compare	and Pop
   DC E0+i	   FSUBR	ST(i),ST						Reverse	Subtract
   DC E8+i	   FSUB		ST(i),ST						Subtract
   DC F0+i	   FDIVR	ST(i),ST						Reverse	Divide
   DC F8+i	   FDIV		ST(i),ST						Divide
   DD /0	   FLD		m64							Load
   DD /1	   FISTTP	m64			SSE3				Integer	Store with Truncation and Pop
   DD /2	   FST		m64							Store
   DD /3	   FSTP		m64							Store and Pop
   DD /4	   FRSTOR	m94/108							Restore	FPU State
   DD /6	   FSAVE	m94/108							Save FPU State
   DD /7	   FSTSW	m2							Store FPU Status Word
   DD C0+i	   FFREE	ST(i)							Free Register
   DD C8+i	   FXCH		ST(i)			undocumented duplicate		Exchange
   DD D0+i	   FST		ST(i)							Store
   DD D8+i	   FSTP		ST(i)							Store and Pop
   DD E0+i	   FUCOM	ST(i)			387+ FUCOM is DD E1		Unordered Compare
   DD E8+i	   FUCOMP	ST(i)			387+ FUCOMP is DD E9		Unordered Compare and Pop
   DE /0	   FIADD	m16							Integer	Add
   DE /1	   FIMUL	m16							Integer	Multiply
   DE /2	   FICOM	m16							Integer	Compare
   DE /3	   FICOMP	m16							Integer	Compare	and Pop
   DE /4	   FISUB	m16							Integer	Subtract
   DE /5	   FISUBR	m16							Integer	Reverse	Subtract
   DE /6	   FIDIV	m16							Integer	Divide
   DE /7	   FIDIVR	m16							Integer	Reverse	Divide
   DE C0+i	   FADDP	ST(i),ST		FADD is	DE C1			Add and	Pop
   DE C8+i	   FMULP	ST(i),ST		FMUL is	DE C9			Multiply and Pop
   DE D0+i	   FCOMP	ST(i)			undocumented duplicate		Compare	and Pop
   DE D9	   FCOMPP								Compare	and Pop	Twice
   DE E0+i	   FSUBRP	ST(i),ST		FSUBR is DE E1			Reverse	Subtract and Pop
   DE E8+i	   FSUBP	ST(i),ST		FSUB is	DE E9			Subtract and Pop
   DE F0+i	   FDIVRP	ST(i),ST		FDIVR is DE F1			Reverse	Divide and Pop
   DE F8+i	   FDIVP	ST(i),ST		FDIV is	DE F9			Divide and Pop
   DF /0	   FILD		m16							Integer	Load
   DF /1	   FISTTP	m16			SSE3				Integer	Store with Truncation and Pop
   DF /2	   FIST		m16							Integer	Store
   DF /3	   FISTP	m16							Integer	Store and Pop
   DF /4	   FBLD		m80							BCD Load
   DF /5	   FILD		m64							Integer	Load
   DF /6	   FBSTP	m80							BCD Store and Pop
   DF /7	   FISTP	m64							Integer	Store and Pop
   DF C0+i	   FFREEP	ST(i)			undocumented			Free Register and Pop
   DF C8+i	   FXCH		ST(i)			undocumented duplicate		Exchange
   DF D0+i	   FSTP		ST(i)			undocumented duplicate		Store and Pop
   DF D8+i	   FSTP		ST(i)			undocumented duplicate		Store and Pop
   DF E0	   FSTSW	AX			287+				Store FPU Status Word
   DF E8+i	   FUCOMIP	ST,ST(i)		P6+				Unordered Compare and Set EFLAGS and Pop
   DF F0+i	   FCOMIP	ST,ST(i)		P6+				Compare	and Set	EFLAGS and Pop
   E0 rel	   LOOPNZ	rel8			also LOOPNE			Loop if	Not Zero
   E1 rel	   LOOPZ	rel8			also LOOPE			Loop if	Zero
   E2 rel	   LOOP		rel8							Loop
   E3 rel	   JCXZ		rel8			JECXZ if 32-bit			Jump if	CX/ECX Zero
   E4 ib	   IN		AL,i8							Input from Port
   E5 ib	   IN		eAX,i8							Input from Port
   E6 ib	   OUT		i8,AL							Output to Port
   E7 ib	   OUT		i8,eAX							Output to Port
   E8 rel	   CALL		rel16/32						Call
   E9 rel	   JMP		rel16/32						Jump
   EA ptr	   JMP		ptr16:16/32						Jump
   EB rel	   JMP		rel8							Jump
   EC		   IN		AL,DX							Input from Port
   ED		   IN		eAX,DX							Input from Port
   EE		   OUT		DX,AL							Output to Port
   EF		   OUT		DX,eAX							Output to Port
   F0		   LOCK									Assert Lock# Signal Prefix
   F1		   INT1					386+ undocumented		Interrupt/ICE Breakpoint
   F2		   REPNZ				also REPNE			Repeat String Operation	Prefix
   F3		   REPZ					also REPE and REP		Repeat String Operation	Prefix
   F4		   HLT									Halt
   F5		   CMC									Complement Carry Flag
   F6 /0 ib	   TEST		r/m8,i8							Test
   F6 /1 ib	   TEST		r/m8,i8			undocumented, same as /0	Test
   F6 /2	   NOT		r/m8							NOT
   F6 /3	   NEG		r/m8							Negate
   F6 /4	   MUL		r/m8							Unsigned Multiply
   F6 /5	   IMUL		r/m8							Signed Multiply
   F6 /6	   DIV		r/m8							Unsigned Divide
   F6 /7	   IDIV		r/m8							Signed Divide
   F7 /0 iw/id	   TEST		r/m16/32,i16/32						Test
   F7 /1 iw/id	   TEST		r/m16/32,i16/32		undocumented, same as /0	Test
   F7 /2	   NOT		r/m16/32						NOT
   F7 /3	   NEG		r/m16/32						Negate
   F7 /4	   MUL		r/m16/32						Unsigned Multiply
   F7 /5	   IMUL		r/m16/32						Signed Multiply
   F7 /6	   DIV		r/m16/32						Unsigned Divide
   F7 /7	   IDIV		r/m16/32						Signed Divide
   F8		   CLC									Clear Carry Flag
   F9		   STC									Set Carry Flag
   FA		   CLI									Clear Interrupt	Flag
   FB		   STI									Set Interrupt Flag
   FC		   CLD									Clear Direction	Flag
   FD		   STD									Set Direction Flag
   FE /0	   INC		r/m8							Increment
   FE /1	   DEC		r/m8							Decrement
   FF /0	   INC		r/m16/32						Increment
   FF /1	   DEC		r/m16/32						Decrement
   FF /2	   CALL		r/m16/32						Call
   FF /3	   CALL		m16:16/32						Call
   FF /4	   JMP		r/m16/32						Jump
   FF /5	   JMP		m16:16/32						Jump
   FF /6	   PUSH		m16/32							Push

   0F 00 /0	   SLDT		r/m16			286+				Store Local Descriptor Table Register
   0F 00 /1	   STR		r/m16			286+				Store Task Register
   0F 00 /2	   LLDT		r/m16			286+				Load Local Descriptor Table Register
   0F 00 /3	   LTR		r/m16			286+				Load Task Register
   0F 00 /4	   VERR		r/m16			286+				Verify Segment for Reading
   0F 00 /5	   VERW		r/m16			286+				Verify Segment for Writing
   0F 01 /0	   SGDT		m16&32			286+				Store Global Descriptor	Table Register
   0F 01 /1	   SIDT		m16&32			286+				Store Interrupt	Descriptor Table Register
   0F 01 /2	   LGDT		m16&32			286+				Load Global Descriptor Table Register
   0F 01 /3	   LIDT		m16&32			286+				Load Interrupt Descriptor Table	Register
   0F 01 /4	   SMSW		r/m16			286+				Store Machine Status Word
   0F 01 /6	   LMSW		r/m16			286+				Load Machine Status Word
   0F 01 /7	   INVLPG	m			486+				Invalidate TLB Entry for Page
   0F 01 C1	   VMCALL				VMX				Call to	VM Monitor
   0F 01 C2	   VMLAUNCH				VMX				Launch Virtual Machine
   0F 01 C3	   VMRESUME				VMX				Resume Virtual Machine
   0F 01 C4	   VMXOFF				VMX				Leave VMX Operation
   0F 01 C8	   MONITOR				SSE3				Set Up Monitor Address
   0F 01 C9	   MWAIT				SSE3				Monitor	Wait
   0F 01 D0	   XGETBV				XSAVE				Get Extended Control Register
   0F 01 D1	   XSETBV				XSAVE				Set Extended Control Register
   0F 01 D4	   VMFUNC				VMX				Invoke VM function
   0F 01 F9	   RDTSCP				RDTSCP				Read Time-Stamp	Counter	and Processor ID
   0F 02 /r	   LAR		r16/32,r/m16/32		286+				Load Access Rights
   0F 03 /r	   LSL		r16/32,r/m16/32		286+				Load Segment Limit
   0F 05	   LOADALL				286 only, undocumented		Load All CPU Registers
   0F 06	   CLTS					286+				Clear Task-Switched Flag in CR0
   0F 07	   LOADALL				386 only, undocumented		Load All CPU Registers
   0F 08	   INVD					486+				Invalidate Caches
   0F 09	   WBINVD				486+				Write Back and Invalidate Caches
   0F 0B	   (UD2)								Undefined Opcode
   0F 0D /1	   PREFETCHW	m8			PREFETCHW			Prefetch Data into Caches in Anticipation of a Write
   0F 10 /r	   MOVUPS	xmm,xmm/m128		SSE				Move Unaligned Packed Single-Precision FP Values
F3 0F 10 /r	   MOVSS	xmm,xmm/m32		SSE				Move Scalar Single-Precision FP	Values
66 0F 10 /r	   MOVUPD	xmm,xmm/m128		SSE2				Move Unaligned Packed Double-Precision FP Values
F2 0F 10 /r	   MOVSD	xmm,xmm/m64		SSE2				Move Scalar Double-Precision FP	Value
   0F 11 /r	   MOVUPS	xmm/m128,xmm		SSE				Move Unaligned Packed Single-Precision FP Values
F3 0F 11 /r	   MOVSS	xmm/m32,xmm		SSE				Move Scalar Single-Precision FP	Values
66 0F 11 /r	   MOVUPD	xmm/m128,xmm		SSE2				Move Unaligned Packed Double-Precision FP Values
F2 0F 11 /r	   MOVSD	xmm/m64,xmm		SSE2				Move Scalar Double-Precision FP	Value
   0F 12 /r	   MOVLPS	xmm,m64			SSE				Move Low Packed	Single-Precision FP Values
   0F 12 /r	   MOVHLPS	xmm,xmm			SSE				Move Packed Single-Precision FP	Values High to Low
66 0F 12 /r	   MOVLPD	xmm,m64			SSE2				Move Low Packed	Double-Precision FP Value
F2 0F 12 /r	   MOVDDUP	xmm,xmm/m64		SSE3				Move One Double-Precision FP Value and Duplicate
F3 0F 12 /r	   MOVSLDUP	xmm,xmm/m128		SSE3				Move Packed Single-Precision FP	Low and	Duplicate
   0F 13 /r	   MOVLPS	m64,xmm			SSE				Move Low Packed	Single-Precision FP Values
66 0F 13 /r	   MOVLPD	m64,xmm			SSE2				Move Low Packed	Double-Precision FP Value
   0F 14 /r	   UNPCKLPS	xmm,xmm/m128		SSE				Unpack and Interleave Low Packed Single-Precision FP Values
66 0F 14 /r	   UNPCKLPD	xmm,xmm/m128		SSE2				Unpack and Interleave Low Packed Double-Precision FP Values
   0F 15 /r	   UNPCKHPS	xmm,xmm/m128		SSE				Unpack and Interleave High Packed Single-Precision FP Values
66 0F 15 /r	   UNPCKHPD	xmm,xmm/m128		SSE2				Unpack and Interleave High Packed Double-Precision FP Values
   0F 16 /r	   MOVHPS	xmm,m64			SSE				Move High Packed Single-Precision FP Values
   0F 16 /r	   MOVLHPS	xmm,xmm			SSE				Move Packed Single-Precision FP	Values Low to High
66 0F 16 /r	   MOVHPD	xmm,m64			SSE2				Move High Packed Double-Precision FP Value
F3 0F 16 /r	   MOVSHDUP	xmm,xmm/m128		SSE3				Move Packed Single-Precision FP	High and Duplicate
   0F 17 /r	   MOVHPS	m64,xmm			SSE				Move High Packed Single-Precision FP Values
66 0F 17 /r	   MOVHPD	m64,xmm			SSE2				Move High Packed Double-Precision FP Value
   0F 18 /0	   PREFETCHNTA	m8			SSE				Prefetch Data into Caches
   0F 18 /1	   PREFETCHT0	m8			SSE				Prefetch Data into Caches
   0F 18 /2	   PREFETCHT1	m8			SSE				Prefetch Data into Caches
   0F 18 /3	   PREFETCHT2	m8			SSE				Prefetch Data into Caches
   0F 18 /n	   ***					P6+				Hintable NOP
   0F 19 /n	   ***					P6+				Hintable NOP
   0F 1A /n	   ***					P6+				Hintable NOP
   0F 1B /n	   ***					P6+				Hintable NOP
   0F 1C /n	   ***					P6+				Hintable NOP
   0F 1D /n	   ***					P6+				Hintable NOP
   0F 1E /n	   ***					P6+				Hintable NOP
   0F 1F /n	   ***					P6+				Hintable NOP
   0F 20 /c	   MOV		r32,CRn			386+				Move from Control Register
   0F 21 /d	   MOV		r32,DRn			386+				Move from Debug	Register
   0F 22 /c	   MOV		CRn,r32			386+				Move to	Control	Register
   0F 23 /d	   MOV		DRn,r32			386+				Move to	Debug Register
   0F 24 /t	   MOV		r32,TRn			386/486	only			Move from Test Register
   0F 26 /t	   MOV		TRn,r32			386/486	only			Move to	Test Register
   0F 28 /r	   MOVAPS	xmm,xmm/m128		SSE				Move Aligned Packed Single-Precision FP	Values
66 0F 28 /r	   MOVAPD	xmm,xmm/m128		SSE2				Move Aligned Packed Double-Precision FP	Values
   0F 29 /r	   MOVAPS	xmm/m128,xmm		SSE				Move Aligned Packed Single-Precision FP	Values
66 0F 29 /r	   MOVAPD	xmm/m128,xmm		SSE2				Move Aligned Packed Double-Precision FP	Values
   0F 2A /r	   CVTPI2PS	xmm,mm/m64		SSE				Convert	Packed Doubleword Integers to Packed Single-Precision FP Values
F3 0F 2A /r	   CVTSI2SS	xmm,r/m32		SSE				Convert	Doubleword Integer to Scalar Single-Precision FP Value
66 0F 2A /r	   CVTPI2PD	xmm,mm/m64		SSE2				Convert	Packed Doubleword Integers to Packed Double-Precision FP Values
F2 0F 2A /r	   CVTSI2SD	xmm,r/m32		SSE2				Convert	Doubleword Integer to Scalar Double-Precision FP Value
   0F 2B /r	   MOVNTPS	m128,xmm		SSE				Store Packed Single-Precision FP Values	Using Non-Temporal Hint
66 0F 2B /r	   MOVNTPD	m128,xmm		SSE2				Store Packed Double-Precision FP Values	Using Non-Temporal Hint
F3 0F 2B /r	   MOVNTSS	m128,xmm		SSE4A				Move Non-Temporal Scalar Single-Precision FP Value
F2 0F 2B /r	   MOVNTSD	m128,xmm		SSE4A				Move Non-Temporal Scalar Double-Precision FP Value
   0F 2C /r	   CVTTPS2PI	mm,xmm/m64		SSE				Convert	with Truncation	Packed Single-Precision	FP Values to Packed Doubleword Integers
F3 0F 2C /r	   CVTTSS2SI	r32,xmm/m32		SSE				Convert	with Truncation	Scalar Single-Precision	FP Value to Doubleword Integer
66 0F 2C /r	   CVTTPD2PI	mm,xmm/m128		SSE2				Convert	with Truncation	Packed Double-Precision	FP Values to Packed Doubleword Integers
F2 0F 2C /r	   CVTTSD2SI	r32,xmm/m64		SSE2				Convert	with Truncation	Scalar Double-Precision	FP Value to Signed Integer
   0F 2D /r	   CVTPS2PI	mm,xmm/m64		SSE				Convert	Packed Single-Precision	FP Values to Packed Doubleword Integers
F3 0F 2D /r	   CVTSS2SI	r32,xmm/m32		SSE				Convert	Scalar Single-Precision	FP Value to Doubleword Integer
66 0F 2D /r	   CVTPD2PI	mm,xmm/m128		SSE2				Convert	Packed Double-Precision	FP Values to Packed Doubleword Integers
F2 0F 2D /r	   CVTSD2SI	r32,xmm/m64		SSE2				Convert	Scalar Double-Precision	FP Value to Doubleword Integer
   0F 2E /r	   UCOMISS	xmm,xmm/m32		SSE				Unordered Compare Scalar Single-Precision FP Values and	Set EFLAGS
66 0F 2E /r	   UCOMISD	xmm,xmm/m64		SSE2				Unordered Compare Scalar Double-Precision FP Values and	Set EFLAGS
   0F 2F /r	   COMISS	xmm,xmm/m32		SSE				Compare	Scalar Ordered Single-Precision	FP Values and Set EFLAGS
66 0F 2F /r	   COMISD	xmm,xmm/m64		SSE2				Compare	Scalar Ordered Double-Precision	FP Values and Set EFLAGS
   0F 30	   WRMSR				P5+				Write Model Specific Register
   0F 31	   RDTSC				P5+				Read Time Stamp	Counter
   0F 32	   RDMSR				P5+				Read Model Specific Register
   0F 33	   RDPMC				P6+ and	Pentium	MMX		Read Performance Monitoring Counters
   0F 34	   SYSENTER				P6+				Fast System Call
   0F 35	   SYSEXIT				P6+				Fast System Return
   0F 37	   GETSEC				SMX
   0F 38	   ***					three-byte opcodes
   0F 3A	   ***					three-byte opcodes
   0F 40 /r	   CMOVO	r16/32,r/m16/32		P6+				Conditional Move if Overflow
   0F 41 /r	   CMOVNO	r16/32,r/m16/32		P6+				Conditional Move if Not	Overflow
   0F 42 /r	   CMOVC	r16/32,r/m16/32		P6+ also CMOVB and CMOVNAE	Conditional Move if Carry
   0F 43 /r	   CMOVNC	r16/32,r/m16/32		P6+ also CMOVAE	and CMOVNB	Conditional Move if Not	Carry
   0F 44 /r	   CMOVZ	r16/32,r/m16/32		P6+ also CMOVE			Conditional Move if Zero
   0F 45 /r	   CMOVNZ	r16/32,r/m16/32		P6+ also CMOVNE			Conditional Move if Not	Zero
   0F 46 /r	   CMOVBE	r16/32,r/m16/32		P6+ also CMOVNA			Conditional Move if Below or Equal
   0F 47 /r	   CMOVA	r16/32,r/m16/32		P6+ also CMOVNBE		Conditional Move if Above
   0F 48 /r	   CMOVS	r16/32,r/m16/32		P6+				Conditional Move if Sign
   0F 49 /r	   CMOVNS	r16/32,r/m16/32		P6+				Conditional Move if Not	Sign
   0F 4A /r	   CMOVP	r16/32,r/m16/32		P6+ also CMOVPE			Conditional Move if Parity
   0F 4B /r	   CMOVNP	r16/32,r/m16/32		P6+ also CMOVPO			Conditional Move if Not	Parity
   0F 4C /r	   CMOVL	r16/32,r/m16/32		P6+ also CMOVNGE		Conditional Move if Less Than
   0F 4D /r	   CMOVGE	r16/32,r/m16/32		P6+ also CMOVNL			Conditional Move if Greater Than or Equal
   0F 4E /r	   CMOVLE	r16/32,r/m16/32		P6+ also CMOVNG			Conditional Move if Less Than or Equal
   0F 4F /r	   CMOVG	r16/32,r/m16/32		P6+ also CMOVNLE		Conditional Move if Greater Than
   0F 50 /r	   MOVMSKPS	r32,xmm			SSE				Extract	Packed Single-Precision	FP Sign	Mask
66 0F 50 /r	   MOVMSKPD	r32,xmm			SSE2				Extract	Packed Double-Precision	FP Sign	Mask
   0F 51 /r	   SQRTPS	xmm,xmm/m128		SSE				Compute	Square Roots of	Packed Single-Precision	FP Values
F3 0F 51 /r	   SQRTSS	xmm,xmm/m32		SSE				Compute	Square Root of Scalar Single-Precision FP Value
66 0F 51 /r	   SQRTPD	xmm,xmm/m128		SSE2				Compute	Square Roots of	Packed Double-Precision	FP Values
F2 0F 51 /r	   SQRTSD	xmm,xmm/m64		SSE2				Compute	Square Root of Scalar Double-Precision FP Value
   0F 52 /r	   RSQRTPS	xmm,xmm/m128		SSE				Compute	Reciprocals of Square Roots of Packed Single-Precision FP Values
F3 0F 52 /r	   RSQRTSS	xmm,xmm/m32		SSE				Compute	Reciprocals of Square Roots of Scalar Single-Precision FP Value
   0F 53 /r	   RCPPS	xmm,xmm/m128		SSE				Compute	Reciprocals of Packed Single-Precision FP Values
F3 0F 53 /r	   RCPSS	xmm,xmm/m32		SSE				Compute	Reciprocals of Scalar Single-Precision FP Values
   0F 54 /r	   ANDPS	xmm,xmm/m128		SSE				AND of Packed Single-Precision FP Values
66 0F 54 /r	   ANDPD	xmm,xmm/m128		SSE2				AND of Packed Double-Precision FP Values
   0F 55 /r	   ANDNPS	xmm,xmm/m128		SSE				AND NOT	of Packed Single-Precision FP Values
66 0F 55 /r	   ANDNPD	xmm,xmm/m128		SSE2				AND NOT	of Packed Double-Precision FP Values
   0F 56 /r	   ORPS		xmm,xmm/m128		SSE				OR of Single-Precision FP Values
66 0F 56 /r	   ORPD		xmm,xmm/m128		SSE2				OR of Double-Precision FP Values
   0F 57 /r	   XORPS	xmm,xmm/m128		SSE				XOR of Single-Precision	FP Values
66 0F 57 /r	   XORPD	xmm,xmm/m128		SSE2				XOR of Double-Precision	FP Values
   0F 58 /r	   ADDPS	xmm,xmm/m128		SSE				Add Packed Single-Precision FP Values
F3 0F 58 /r	   ADDSS	xmm,xmm/m32		SSE				Add Scalar Single-Precision FP Values
66 0F 58 /r	   ADDPD	xmm,xmm/m128		SSE2				Add Packed Double-Precision FP Values
F2 0F 58 /r	   ADDSD	xmm,xmm/m64		SSE2				Add Scalar Double-Precision FP Values
   0F 59 /r	   MULPS	xmm,xmm/m128		SSE				Multiply Packed	Single-Precision FP Values
F3 0F 59 /r	   MULSS	xmm,xmm/m32		SSE				Multiply Scalar	Single-Precision FP Values
66 0F 59 /r	   MULPD	xmm,xmm/m128		SSE2				Multiply Packed	Double-Precision FP Values
F2 0F 59 /r	   MULSD	xmm,xmm/m64		SSE2				Multiply Scalar	Double-Precision FP Values
   0F 5A /r	   CVTPS2PD	xmm,xmm/m64		SSE2				Convert	Packed Single-Precision	FP Values to Packed Double-Precision FP	Values
F3 0F 5A /r	   CVTSS2SD	xmm,xmm/m32		SSE2				Convert	Scalar Single-Precision	FP Value to Scalar Double-Precision FP Value
66 0F 5A /r	   CVTPD2PS	xmm,xmm/m128		SSE2				Convert	Packed Double-Precision	FP Values to Packed Single-Precision FP	Values
F2 0F 5A /r	   CVTSD2SS	xmm,xmm/m64		SSE2				Convert	Scalar Double-Precision	FP Value to Scalar Single-Precision FP Value
   0F 5B /r	   CVTDQ2PS	xmm,xmm/m128		SSE2				Convert	Packed Doubleword Integers to Packed Single-Precision FP Values
66 0F 5B /r	   CVTPS2DQ	xmm,xmm/m128		SSE2				Convert	Packed Single-Precision	FP Values to Packed Doubleword Integers
F3 0F 5B /r	   CVTTPS2DQ	xmm,xmm/m128		SSE2				Convert	with Truncation	Packed Single-Precision	FP Values to Packed Doubleword Integers
   0F 5C /r	   SUBPS	xmm,xmm/m128		SSE				Subtract Packed	Single-Precision FP Values
F3 0F 5C /r	   SUBSS	xmm,xmm/m32		SSE				Subtract Scalar	Single-Precision FP Values
66 0F 5C /r	   SUBPD	xmm,xmm/m128		SSE2				Subtract Packed	Double-Precision FP Values
F2 0F 5C /r	   SUBSD	xmm,xmm/m64		SSE2				Subtract Scalar	Double-Precision FP Values
   0F 5D /r	   MINPS	xmm,xmm/m128		SSE				Return Minimum Packed Single-Precision FP Values
F3 0F 5D /r	   MINSS	xmm,xmm/m32		SSE				Return Minimum Scalar Single-Precision FP Value
66 0F 5D /r	   MINPD	xmm,xmm/m128		SSE2				Return Minimum Packed Double-Precision FP Values
F2 0F 5D /r	   MINSD	xmm,xmm/m64		SSE2				Return Minimum Scalar Double-Precision FP Value
   0F 5E /r	   DIVPS	xmm,xmm/m128		SSE				Divide Packed Single-Precision FP Values
F3 0F 5E /r	   DIVSS	xmm,xmm/m32		SSE				Divide Scalar Single-Precision FP Values
66 0F 5E /r	   DIVPD	xmm,xmm/m128		SSE2				Divide Packed Double-Precision FP Values
F2 0F 5E /r	   DIVSD	xmm,xmm/m64		SSE2				Divide Scalar Double-Precision FP Values
   0F 5F /r	   MAXPS	xmm,xmm/m128		SSE				Return Maximum Packed Single-Precision FP Values
F3 0F 5F /r	   MAXSS	xmm,xmm/m32		SSE				Return Maximum Scalar Single-Precision FP Value
66 0F 5F /r	   MAXPD	xmm,xmm/m128		SSE2				Return Maximum Packed Double-Precision FP Values
F2 0F 5F /r	   MAXSD	xmm,xmm/m64		SSE2				Return Maximum Scalar Double-Precision FP Value
   0F 60 /r	   PUNPCKLBW	mm,mm/m32		MMX				Unpack Low Data	Bytes to Words
66 0F 60 /r	   PUNPCKLBW	xmm,xmm/m128		SSE2				Unpack Low Data	Bytes to Words
   0F 61 /r	   PUNPCKLWD	mm,mm/m32		MMX				Unpack Low Data	Words to Doublewords
66 0F 61 /r	   PUNPCKLWD	xmm,xmm/m128		SSE2				Unpack Low Data	Words to Doublewords
   0F 62 /r	   PUNPCKLDQ	mm,mm/m32		MMX				Unpack Low Data	Doublewords to Quadwords
66 0F 62 /r	   PUNPCKLDQ	xmm,xmm/m128		SSE2				Unpack Low Data	Doublewords to Quadwords
   0F 63 /r	   PACKSSWB	mm,mm/m64		MMX				Pack with Signed Saturation
66 0F 63 /r	   PACKSSWB	xmm,xmm/m128		SSE2				Pack with Signed Saturation
   0F 64 /r	   PCMPGTB	mm,mm/m64		MMX				Packed Compare for Greater Than	Bytes
66 0F 64 /r	   PCMPGTB	xmm,xmm/m128		SSE2				Packed Compare for Greater Than	Bytes
   0F 65 /r	   PCMPGTW	mm,mm/m64		MMX				Packed Compare for Greater Than	Words
66 0F 65 /r	   PCMPGTW	xmm,xmm/m128		SSE2				Packed Compare for Greater Than	Words
   0F 66 /r	   PCMPGTD	mm,mm/m64		MMX				Packed Compare for Greater Than	Doublewords
66 0F 66 /r	   PCMPGTD	xmm,xmm/m128		SSE2				Packed Compare for Greater Than	Doublewords
   0F 67 /r	   PACKUSWB	mm,mm/m64		MMX				Pack with Unsigned Saturation
66 0F 67 /r	   PACKUSWB	xmm,mm/m128		SSE2				Pack with Unsigned Saturation
   0F 68 /r	   PUNPCKHBW	mm,mm/m64		MMX				Unpack High Data Bytes to Words
66 0F 68 /r	   PUNPCKHBW	xmm,xmm/m128		SSE2				Unpack High Data Bytes to Words
   0F 69 /r	   PUNPCKHWD	mm,mm/m64		MMX				Unpack High Data Words to Doublewords
66 0F 69 /r	   PUNPCKHWD	xmm,xmm/m128		SSE2				Unpack High Data Words to Doublewords
   0F 6A /r	   PUNPCKHDQ	mm,mm/m64		MMX				Unpack High Data Doublewords to	Quadwords
66 0F 6A /r	   PUNPCKHDQ	xmm,xmm/m128		SSE2				Unpack High Data Doublewords to	Quadwords
   0F 6B /r	   PACKSSDW	mm,mm/m64		MMX				Pack with Signed Saturation Doublewords	to Words
66 0F 6B /r	   PACKSSDW	xmm,xmm/m128		SSE2				Pack with Signed Saturation Doublewords	to Words
66 0F 6C /r	   PUNPCKLQDQ	xmm,xmm/m128		SSE2				Unpack Low Data	Quadword to Double Quadword
66 0F 6D /r	   PUNPCKHQDQ	xmm,xmm/m128		SSE2				Unpack High Data Quadword to Double Quadword
   0F 6E /r	   MOVD		mm,r/m32		MMX				Move Doubleword
66 0F 6E /r	   MOVD		xmm,r/m32		SSE2				Move Doubleword
   0F 6F /r	   MOVQ		mm,mm/m64		MMX				Move Quadword
66 0F 6F /r	   MOVDQA	xmm,xmm/m128		SSE2				Move Aligned Double Quadword
F3 0F 6F /r	   MOVDQU	xmm,xmm/m128		SSE2				Move Unaligned Double Quadword
   0F 70 /r ib	   PSHUFW	mm,mm/m64,i8		SSE				Packed Shuffle
66 0F 70 /r ib	   PSHUFD	xmm,xmm/m128,i8		SSE2				Packed Shuffle
F2 0F 70 /r ib	   PSHUFLW	xmm,xmm/m128,i8		SSE2				Packed Shuffle Low Words
F3 0F 70 /r ib	   PSHUFHW	xmm,xmm/m128,i8		SSE2				Packed Shuffle High Words
   0F 71 /2 ib	   PSRLW	mm,i8			MMX				Packed Shift Right Words
66 0F 71 /2 ib	   PSRLW	xmm,i8			SSE2				Packed Shift Right Words
   0F 71 /4 ib	   PSRAW	mm,i8			MMX				Packed Shift Right Arithmetic Words
66 0F 71 /4 ib	   PSRAW	xmm,i8			SSE2				Packed Shift Right Arithmetic Words
   0F 71 /6 ib	   PSLLW	mm,i8			MMX				Packed Shift Left Words
66 0F 71 /6 ib	   PSLLW	xmm,i8			SSE2				Packed Shift Left Words
   0F 72 /2 ib	   PSRLD	mm,i8			MMX				Packed Shift Right Doublewords
66 0F 72 /2 ib	   PSRLD	xmm,i8			SSE2				Packed Shift Right Doublewords
   0F 72 /4 ib	   PSRAD	mm,i8			MMX				Packed Shift Right Arithmetic Doublewords
66 0F 72 /4 ib	   PSRAD	xmm,i8			SSE2				Packed Shift Right Arithmetic Doublewords
   0F 72 /6 ib	   PSLLD	mm,i8			MMX				Packed Shift Left Doublewords
66 0F 72 /6 ib	   PSLLD	xmm,i8			SSE2				Packed Shift Left Doublewords
   0F 73 /2 ib	   PSRLQ	mm,i8			MMX				Packed Shift Right Quadwords
66 0F 73 /2 ib	   PSRLQ	xmm,i8			SSE2				Packed Shift Right Quadwords
66 0F 73 /3 ib	   PSRLDQ	xmm,i8			SSE2				Packed Shift Right Double Quadword
   0F 73 /6 ib	   PSLLQ	mm,i8			MMX				Packed Shift Left Quadwords
66 0F 73 /6 ib	   PSLLQ	xmm,i8			SSE2				Packed Shift Left Quadwords
66 0F 73 /7 ib	   PSLLDQ	xmm,i8			SSE2				Packed Shift Left Double Quadword
   0F 74 /r	   PCMPEQB	mm,mm/m64		MMX				Packed Compare for Equal Bytes
66 0F 74 /r	   PCMPEQB	xmm,xmm/m128		SSE2				Packed Compare for Equal Bytes
   0F 75 /r	   PCMPEQW	mm,mm/m64		MMX				Packed Compare for Equal Words
66 0F 75 /r	   PCMPEQW	xmm,xmm/m128		SSE2				Packed Compare for Equal Words
   0F 76 /r	   PCMPEQD	mm,mm/m64		MMX				Packed Compare for Equal Doublewords
66 0F 76 /r	   PCMPEQD	xmm,xmm/m128		SSE2				Packed Compare for Equal Doublewords
   0F 77	   EMMS					MMX				Empty MMX State
   0F 78 /r	   VMREAD	r/m32,r32		VMX				Read Field from	Virtual-Machine	Control	Structure
66 0F 78 /0 ib ib  EXTRQ	xmm,i8,i8		SSE4A				Extract	Field From Register
F2 0F 78 /0 ib ib  INSERTQ	xmm,xmm,i8,i8		SSE4A				Insert Field
   0F 79 /r	   VMWRITE	r32,r/m32		VMX				Write Field to Virtual-Machine Control Structure
66 0F 79 /r	   EXTRQ	xmm,xmm			SSE4A				Extract	Field From Register
F2 0F 79 /r	   INSERTQ	xmm,xmm			SSE4A				Insert Field
66 0F 7C /r	   HADDPD	xmm,xmm/m128		SSE3				Packed Double-Precision	FP Horizontal Add
F2 0F 7C /r	   HADDPS	xmm,xmm/m128		SSE3				Packed Single-Precision	FP Horizontal Add
66 0F 7D /r	   HSUBPD	xmm,xmm/m128		SSE3				Packed Double-Precision	FP Horizontal Subtract
F2 0F 7D /r	   HSUBPS	xmm,xmm/m128		SSE3				Packed Single-Precision	FP Horizontal Subtract
   0F 7E /r	   MOVD		r/m32,mm		MMX				Move Doubleword
66 0F 7E /r	   MOVD		r/m32,xmm		SSE2				Move Doubleword
F3 0F 7E /r	   MOVQ		xmm,xmm/m64		SSE2				Move Quadword
   0F 7F /r	   MOVQ		mm/m64,mm		MMX				Move Quadword
66 0F 7F /r	   MOVDQA	xmm/m128,xmm		SSE2				Move Aligned Double Quadword
F3 0F 7F /r	   MOVDQU	xmm/m128,xmm		SSE2				Move Unaligned Double Quadword
   0F 80 rel	   JO		rel16			386+				Jump if	Overflow
   0F 81 rel	   JNO		rel16			386+				Jump if	Not Overflow
   0F 82 rel	   JC		rel16			386+ also JB and JNAE		Jump if	Carry
   0F 83 rel	   JNC		rel16			386+ also JAE and JNB		Jump if	Not Carry
   0F 84 rel	   JZ		rel16			386+ also JE			Jump if	Zero
   0F 85 rel	   JNZ		rel16			386+ also JNE			Jump if	Not Zero
   0F 86 rel	   JBE		rel16			386+ also JNA			Jump if	Below or Equal
   0F 87 rel	   JA		rel16			386+ also JNBE			Jump if	Above
   0F 88 rel	   JS		rel16			386+				Jump if	Sign
   0F 89 rel	   JNS		rel16			386+				Jump if	Not Sign
   0F 8A rel	   JP		rel16			386+ also JPE			Jump if	Parity
   0F 8B rel	   JNP		rel16			386+ also JPO			Jump if	Not Parity
   0F 8C rel	   JL		rel16			386+ also JNGE			Jump if	Less Than
   0F 8D rel	   JGE		rel16			386+ also JNL			Jump if	Greater	Than or	Equal
   0F 8E rel	   JLE		rel16			386+ also JNG			Jump if	Less Than or Equal
   0F 8F rel	   JG		rel16			386+ also JNLE			Jump if	Greater	Than
   0F 90 /0	   SETO		r/m8			386+				Set Byte if Overflow
   0F 91 /0	   SETNO	r/m8			386+				Set Byte if Not	Overflow
   0F 92 /0	   SETC		r/m8			386+ also SETB and SETNAE	Set Byte if Carry
   0F 93 /0	   SETNC	r/m8			386+ also SETAE	and SETNB	Set Byte if Not	Carry
   0F 94 /0	   SETZ		r/m8			386+ also SETE			Set Byte if Zero
   0F 95 /0	   SETNZ	r/m8			386+ also SETNE			Set Byte if Not	Zero
   0F 96 /0	   SETBE	r/m8			386+ also SETNA			Set Byte if Below or Equal
   0F 97 /0	   SETA		r/m8			386+ also SETNBE		Set Byte if Above
   0F 98 /0	   SETS		r/m8			386+				Set Byte if Sign
   0F 99 /0	   SETNS	r/m8			386+				Set Byte if Not	Sign
   0F 9A /0	   SETP		r/m8			386+ also SETPE			Set Byte if Parity
   0F 9B /0	   SETNP	r/m8			386+ also SETPO			Set Byte if Not	Parity
   0F 9C /0	   SETL		r/m8			386+ also SETNGE		Set Byte if Less Than
   0F 9D /0	   SETGE	r/m8			386+ also SETNL			Set Byte if Greater Than or Equal
   0F 9E /0	   SETLE	r/m8			386+ also SETNG			Set Byte if Less Than or Equal
   0F 9F /0	   SETG		r/m8			386+ also SETNLE		Set Byte if Greater Than
   0F A0	   PUSH		FS			386+				Push
   0F A1	   POP		FS			386+				Pop
   0F A2	   CPUID				P5+ and	later 486		CPU Identification
   0F A3 /r	   BT		r/m16/32,r16/32		386+				Bit Test
   0F A4 /r ib	   SHLD		r/m16/32,r16/32,i8	386+				Shift Left Double Precision
   0F A5 /r	   SHLD		r/m16/32,r16/32,CL	386+				Shift Left Double Precision
   0F A6 /r	   XBTS		r16/32,r/m16/32		386 A and B0 step only		Extract	Bit String
   0F A6 /r	   CMPXCHG	r/m8,r8			486 A step only			Compare	and Exchange
   0F A7 /r	   IBTS		r/m16/32,r16/32		386 A and B0 step only		Insert Bit String
   0F A7 /r	   CMPXCHG	r/m16/32,r16/32		486 A step only			Compare	and Exchange
   0F A8	   PUSH		GS			386+				Push
   0F A9	   POP		GS			386+				Pop
   0F AA	   RSM					P5+ and	386SL/486SL		Resume from System Management Mode
   0F AB /r	   BTS		r/m16/32,r16/32		386+				Bit Test and Set
   0F AC /r ib	   SHRD		r/m16/32,r16/32,i8	386+				Shift Right Double Precision
   0F AD /r	   SHRD		r/m16/32,r16/32,CL	386+				Shift Right Double Precision
   0F AE /0	   FXSAVE	m512			FXSR (Pentium II+)		Extended FPU Save State
   0F AE /1	   FXRSTOR	m512			FXSR (Pentium II+)		Extended FPU Restore State
   0F AE /2	   LDMXCSR	m32			SSE				Load MXCSR Register
   0F AE /3	   STMXCSR	m32			SSE				Store MXCSR Register
   0F AE /4	   XSAVE	m512			XSAVE				Save Processor Extended	States
   0F AE /5	   LFENCE				SSE2				Load Fence
   0F AE /5	   XRSTOR	m512			XSAVE				Restore	Processor Extended States
   0F AE /6	   MFENCE				SSE2				Memory Fence
   0F AE /6	   XSAVEOPT	m512			XSAVEOPT			Save Processor Extended	States Optimized
   0F AE /7	   SFENCE				SSE				Store Fence
   0F AE /7	   CLFLUSH	m8			SSE2				Flush Cache Line
   0F AF /r	   IMUL		r16/32,r/m16/32		386+				Signed Multiply
   0F B0 /r	   CMPXCHG	r/m8,r8			486+				Compare	and Exchange
   0F B1 /r	   CMPXCHG	r/m16/32,r16/32		486+				Compare	and Exchange
   0F B2 /r	   LSS		r16/32,m16:16/32	386+				Load Far Pointer
   0F B3 /r	   BTR		r/m16/32,r16/32		386+				Bit Test and Reset
   0F B4 /r	   LFS		r16/32,m16:16/32	386+				Load Far Pointer
   0F B5 /r	   LGS		r16/32,m16:16/32	386+				Load Far Pointer
   0F B6 /r	   MOVZX	r16/32,r/m8		386+				Move with Zero-Extend
   0F B7 /r	   MOVZX	r32,r/m16		386+				Move with Zero-Extend
F3 0F B8 /r	   POPCNT	r16/32,r/m16/32		POPCNT				Population Count
   0F B9 /r	   (UD1)								Undefined Opcode
   0F BA /4 ib	   BT		r/m16/32,i8		386+				Bit Test
   0F BA /5 ib	   BTS		r/m16/32,i8		386+				Bit Test and Set
   0F BA /6 ib	   BTR		r/m16/32,i8		386+				Bit Test and Reset
   0F BA /7 ib	   BTC		r/m16/32,i8		386+				Bit Test and Complement
   0F BB /r	   BTC		r/m16/32,r16/32		386+				Bit Test and Complement
   0F BC /r	   BSF		r16/32,r/m16/32		386+				Bit Scan Forward
F3 0F BC /r	   TZCNT	r16/32,r/m16/32		BMI1				Count the Number of Trailing Zero Bits
   0F BD /r	   BSR		r16/32,r/m16/32		386+				Bit Scan Reverse
F3 0F BD /r	   LZCNT	r16/32,r/m16/32		LZCNT				Count the Number of Leading Zero Bits
   0F BE /r	   MOVSX	r16/32,r/m8		386+				Move with Sign-Extend
   0F BF /r	   MOVSX	r32,r/m16		386+				Move with Sign-Extend
   0F C0 /r	   XADD		r/m8,r8			486+				Exchange and Add
   0F C1 /r	   XADD		r/m16/32,r16/32		486+				Exchange and Add
   0F C2 /r ib	   CMPPS	xmm,xmm/m128,i8		SSE				Compare	Packed Single-Precision	FP Values
F3 0F C2 /r ib	   CMPSS	xmm,xmm/m32,i8		SSE				Compare	Scalar Single-Precision	FP Values
66 0F C2 /r ib	   CMPPD	xmm,xmm/m32,i8		SSE2				Compare	Packed Double-Precision	FP Values
F2 0F C2 /r ib	   CMPSD	xmm,xmm/m64,i8		SSE2				Compare	Scalar Double-Precision	FP Values
   0F C3 /r	   MOVNTI	m32,r32			SSE2				Store Doubleword Using Non-Temporal Hint
   0F C4 /r ib	   PINSRW	mm,r32,i8		SSE				Packed Insert Words
66 0F C4 /r ib	   PINSRW	xmm,r32,i8		SSE2				Packed Insert Words
   0F C5 /r ib	   PEXTRW	r32,mm,i8		SSE				Packed Extract Words
66 0F C5 /r ib	   PEXTRW	r32,xmm,i8		SSE2				Packed Extract Words
   0F C6 /r ib	   SHUFPS	xmm,xmm/m128,i8		SSE				Shuffle	Packed Single-Precision	FP Values
66 0F C6 /r ib	   SHUFPD	xmm,xmm/m128,i8		SSE2				Shuffle	Packed Double-Precision	FP Values
   0F C7 /1	   CMPXCHG8B	m64			P5+				Compare	and Exchange 8 Bytes
   0F C7 /6	   RDRAND	r16/32			RDRAND				Read Random Number
   0F C7 /6	   VMPTRLD	m64			VMX				Load Pointer to	Virtual-Machine	Control	Structure
66 0F C7 /6	   VMCLEAR	m64			VMX				Clear Virtual-Machine Control Structure
F3 0F C7 /6	   VMXON	m64			VMX				Enter VMX Operation
   0F C7 /7	   VMPTRST	m64			VMX				Store Pointer to Virtual-Machine Control Structure
   0F C8	   BSWAP	EAX			486+				Byte Swap
   0F C9	   BSWAP	ECX			486+				Byte Swap
   0F CA	   BSWAP	EDX			486+				Byte Swap
   0F CB	   BSWAP	EBX			486+				Byte Swap
   0F CC	   BSWAP	ESP			486+				Byte Swap
   0F CD	   BSWAP	EBP			486+				Byte Swap
   0F CE	   BSWAP	ESI			486+				Byte Swap
   0F CF	   BSWAP	EDI			486+				Byte Swap
66 0F D0 /r	   ADDSUBPD	xmm,xmm/m128		SSE3				Packed Double-Precision	FP Add/Subtract
F2 0F D0 /r	   ADDSUBPS	xmm,xmm/m128		SSE3				Packed Single-Precision	FP Add/Subtract
   0F D1 /r	   PSRLW	mm,mm/m64		MMX				Packed Shift Right Words
66 0F D1 /r	   PSRLW	xmm,xmm/m128		SSE2				Packed Shift Right Words
   0F D2 /r	   PSRLD	mm,mm/m64		MMX				Packed Shift Right Doublewords
66 0F D2 /r	   PSRLD	xmm,xmm/m128		SSE2				Packed Shift Right Doublewords
   0F D3 /r	   PSRLQ	mm,mm/m64		MMX				Packed Shift Right Quadwords
66 0F D3 /r	   PSRLQ	xmm,xmm/m128		SSE2				Packed Shift Right Quadwords
   0F D4 /r	   PADDQ	mm,mm/m64		SSE2				Packed Add Quadwords
66 0F D4 /r	   PADDQ	xmm,xmm/m128		SSE2				Packed Add Quadwords
   0F D5 /r	   PMULLW	mm,mm/m64		MMX				Packed Multiply	Signed Integers	and Store Low Result
66 0F D5 /r	   PMULLW	xmm,xmm/m128		SSE2				Packed Multiply	Signed Integers	and Store Low Result
66 0F D6 /r	   MOVQ		xmm/m64,xmm		SSE2				Move Quadword
F2 0F D6 /r	   MOVDQ2Q	mm,xmm			SSE2				Move Quadword from XMM to MMX Register
F3 0F D6 /r	   MOVQ2DQ	xmm,mm			SSE2				Move Quadword from MMX to XMM Register
   0F D7 /r	   PMOVMSKB	r32,mm			SSE				Move Byte Mask
66 0F D7 /r	   PMOVMSKB	r32,xmm			SSE2				Move Byte Mask
   0F D8 /r	   PSUBUSB	mm,mm/m64		MMX				Packed Subtract	Unsigned Integers with Unsigned	Saturation Bytes
66 0F D8 /r	   PSUBUSB	xmm,xmm/m128		SSE2				Packed Subtract	Unsigned Integers with Unsigned	Saturation Bytes
   0F D9 /r	   PSUBUSW	mm,mm/m64		MMX				Packed Subtract	Unsigned Integers with Unsigned	Saturation Words
66 0F D9 /r	   PSUBUSW	xmm,xmm/m128		SSE2				Packed Subtract	Unsigned Integers with Unsigned	Saturation Words
   0F DA /r	   PMINUB	mm,mm/m64		SSE				Packed Minimum Unsigned	Integers Bytes
66 0F DA /r	   PMINUB	xmm,xmm/m128		SSE2				Packed Minimum Unsigned	Integers Bytes
   0F DB /r	   PAND		mm,mm/m64		MMX				Packed AND
66 0F DB /r	   PAND		xmm,xmm/m128		SSE2				Packed AND
   0F DC /r	   PADDUSB	mm,mm/m64		MMX				Packed Add Unsigned Integers with Unsigned Saturation Bytes
66 0F DC /r	   PADDUSB	xmm,xmm/m128		SSE2				Packed Add Unsigned Integers with Unsigned Saturation Bytes
   0F DD /r	   PADDUSW	mm,mm/m64		MMX				Packed Add Unsigned Integers with Unsigned Saturation Words
66 0F DD /r	   PADDUSW	xmm,xmm/m128		SSE2				Packed Add Unsigned Integers with Unsigned Saturation Words
   0F DE /r	   PMAXUB	mm,mm/m64		SSE				Packed Maximum Unsigned	Integers Bytes
66 0F DE /r	   PMAXUB	xmm,xmm/m128		SSE2				Packed Maximum Unsigned	Integers Bytes
   0F DF /r	   PANDN	mm,mm/m64		MMX				Packed AND NOT
66 0F DF /r	   PANDN	xmm,xmm/m128		SSE2				Packed AND NOT
   0F E0 /r	   PAVGB	mm,mm/m64		SSE				Packed Average Integers	Bytes
66 0F E0 /r	   PAVGB	xmm,xmm/m128		SSE2				Packed Average Integers	Bytes
   0F E1 /r	   PSRAW	mm,mm/m64		MMX				Packed Shift Right Arithmetic Words
66 0F E1 /r	   PSRAW	xmm,xmm/m128		SSE2				Packed Shift Right Arithmetic Words
   0F E2 /r	   PSRAD	mm,mm/m64		MMX				Packed Shift Right Arithmetic Doublewords
66 0F E2 /r	   PSRAD	xmm,xmm/m128		SSE2				Packed Shift Right Arithmetic Doublewords
   0F E3 /r	   PAVGW	mm,mm/m64		SSE				Packed Average Integers	Words
66 0F E3 /r	   PAVGW	xmm,xmm/m128		SSE2				Packed Average Integers	Words
   0F E4 /r	   PMULHUW	mm,mm/m64		SSE				Packed Multiply	Unsigned Integers and Store High Result
66 0F E4 /r	   PMULHUW	xmm,xmm/m128		SSE2				Packed Multiply	Unsigned Integers and Store High Result
   0F E5 /r	   PMULHW	mm,mm/m64		MMX				Packed Multiply	Signed Integers	and Store High Result
66 0F E5 /r	   PMULHW	xmm,xmm/m128		SSE2				Packed Multiply	Signed Integers	and Store High Result
66 0F E6 /r	   CVTTPD2DQ	xmm,xmm/m128		SSE2				Convert	with Truncation	Packed Double-Precision	FP Values to Packed Doubleword Integers
F2 0F E6 /r	   CVTPD2DQ	xmm,xmm/m128		SSE2				Convert	Packed Double-Precision	FP Values to Packed Doubleword Integers
F3 0F E6 /r	   CVTDQ2PD	xmm,xmm/m64		SSE2				Convert	Packed Doubleword Integers to Packed Double-Precision FP Values
   0F E7 /r	   MOVNTQ	m64,mm			SSE				Store of Quadword Using	Non-Temporal Hint
66 0F E7 /r	   MOVNTDQ	m128,xmm		SSE2				Store Double Quadword Using Non-Temporal Hint
   0F E8 /r	   PSUBSB	mm,mm/m64		MMX				Packed Subtract	Signed Integers	with Signed Saturation Bytes
66 0F E8 /r	   PSUBSB	xmm,xmm/m128		SSE2				Packed Subtract	Signed Integers	with Signed Saturation Bytes
   0F E9 /r	   PSUBSW	mm,mm/m64		MMX				Packed Subtract	Signed Integers	with Signed Saturation Words
66 0F E9 /r	   PSUBSW	xmm,xmm/m128		SSE2				Packed Subtract	Signed Integers	with Signed Saturation Words
   0F EA /r	   PMINSW	mm,mm/m64		SSE				Packed Minimum Signed Integers Words
66 0F EA /r	   PMINSW	xmm,xmm/m128		SSE2				Packed Minimum Signed Integers Words
   0F EB /r	   POR		mm,mm/m64		MMX				Packed OR
66 0F EB /r	   POR		xmm,xmm/m128		SSE2				Packed OR
   0F EC /r	   PADDSB	mm,mm/m64		MMX				Packed Add Signed Integers with	Signed Saturation Bytes
66 0F EC /r	   PADDSB	xmm,xmm/m128		SSE2				Packed Add Signed Integers with	Signed Saturation Bytes
   0F ED /r	   PADDSW	mm,mm/m64		MMX				Packed Add Signed Integers with	Signed Saturation Words
66 0F ED /r	   PADDSW	xmm,xmm/m128		SSE2				Packed Add Signed Integers with	Signed Saturation Words
   0F EE /r	   PMAXSW	mm,mm/m64		SSE				Packed Maximum Signed Integers Words
66 0F EE /r	   PMAXSW	xmm,xmm/m128		SSE2				Packed Maximum Signed Integers Words
   0F EF /r	   PXOR		mm,mm/m64		MMX				Packed XOR
66 0F EF /r	   PXOR		xmm,xmm/m128		SSE2				Packed XOR
F2 0F F0 /r	   LDDQU	xmm,mm			SSE3				Load Double Quadword Unaligned Integer
   0F F1 /r	   PSLLW	mm,mm/m64		MMX				Packed Shift Left Words
66 0F F1 /r	   PSLLW	xmm,xmm/m128		SSE2				Packed Shift Left Words
   0F F2 /r	   PSLLD	mm,mm/m64		MMX				Packed Shift Left Doublewords
66 0F F2 /r	   PSLLD	xmm,xmm/m128		SSE2				Packed Shift Left Doublewords
   0F F3 /r	   PSLLQ	mm,mm/m64		MMX				Packed Shift Left Quadwords
66 0F F3 /r	   PSLLQ	xmm,xmm/m128		SSE2				Packed Shift Left Quadwords
   0F F4 /r	   PMULUDQ	mm,mm/m64		SSE2				Packed Multiply	Unsigned Doubleword Integers
66 0F F4 /r	   PMULUDQ	xmm,xmm/m128		SSE2				Packed Multiply	Unsigned Doubleword Integers
   0F F5 /r	   PMADDWD	mm,mm/m64		MMX				Multiply and Add Packed	Integers
66 0F F5 /r	   PMADDWD	xmm,xmm/m128		SSE2				Multiply and Add Packed	Integers
   0F F6 /r	   PSADBW	mm,mm/m64		SSE				Compute	Sum of Absolute	Differences
66 0F F6 /r	   PSADBW	xmm,xmm/m128		SSE2				Compute	Sum of Absolute	Differences
   0F F7 /r	   MASKMOVQ	mm,mm			SSE				Store Selected Bytes of	Quadword
66 0F F7 /r	   MASKMOVDQU	xmm,xmm			SSE2				Store Selected Bytes of	Double Quadword
   0F F8 /r	   PSUBB	mm,mm/m64		MMX				Packed Subtract	Bytes
66 0F F8 /r	   PSUBB	xmm,xmm/m128		SSE2				Packed Subtract	Bytes
   0F F9 /r	   PSUBW	mm,mm/m64		MMX				Packed Subtract	Words
66 0F F9 /r	   PSUBW	xmm,xmm/m128		SSE2				Packed Subtract	Words
   0F FA /r	   PSUBD	mm,mm/m64		MMX				Packed Subtract	Doublewords
66 0F FA /r	   PSUBD	xmm,xmm/m128		SSE2				Packed Subtract	Doublewords
   0F FB /r	   PSUBQ	mm,mm/m64		SSE2				Packed Subtract	Quadwords
66 0F FB /r	   PSUBQ	xmm,xmm/m128		SSE2				Packed Subtract	Quadwords
   0F FC /r	   PADDB	mm,mm/m64		MMX				Packed Add Bytes
66 0F FC /r	   PADDB	xmm,xmm/m128		SSE2				Packed Add Bytes
   0F FD /r	   PADDW	mm,mm/m64		MMX				Packed Add Words
66 0F FD /r	   PADDW	xmm,xmm/m128		SSE2				Packed Add Words
   0F FE /r	   PADDD	mm,mm/m64		MMX				Packed Add Doublewords
66 0F FE /r	   PADDD	xmm,xmm/m128		SSE2				Packed Add Doublewords
   0F FF	   (UD0)								Undefined Opcode

   0F 38 00 /r	   PSHUFB	mm,mm/m64		SSSE3				Packed Shuffle Bytes
66 0F 38 00 /r	   PSHUFB	xmm,xmm/m128		SSSE3				Packed Shuffle Bytes
   0F 38 01 /r	   PHADDW	mm,mm/m64		SSSE3				Packed Horizontal Add Words
66 0F 38 01 /r	   PHADDW	xmm,xmm/m128		SSSE3				Packed Horizontal Add Words
   0F 38 02 /r	   PHADDD	mm,mm/m64		SSSE3				Packed Horizontal Add Doublewords
66 0F 38 02 /r	   PHADDD	xmm,xmm/m128		SSSE3				Packed Horizontal Add Doublewords
   0F 38 03 /r	   PHADDSW	mm,mm/m64		SSSE3				Packed Horizontal Add and Saturate Words
66 0F 38 03 /r	   PHADDSW	xmm,xmm/m128		SSSE3				Packed Horizontal Add and Saturate Words
   0F 38 04 /r	   PMADDUBSW	mm,mm/m64		SSSE3				Multiply and Add Packed	Signed and Unsigned Bytes
66 0F 38 04 /r	   PMADDUBSW	xmm,xmm/m128		SSSE3				Multiply and Add Packed	Signed and Unsigned Bytes
   0F 38 05 /r	   PHSUBW	mm,mm/m64		SSSE3				Packed Horizontal Subtract Words
66 0F 38 05 /r	   PHSUBW	xmm,xmm/m128		SSSE3				Packed Horizontal Subtract Words
   0F 38 06 /r	   PHSUBD	mm,mm/m64		SSSE3				Packed Horizontal Subtract Doublewords
66 0F 38 06 /r	   PHSUBD	xmm,xmm/m128		SSSE3				Packed Horizontal Subtract Doublewords
   0F 38 07 /r	   PHSUBSW	mm,mm/m64		SSSE3				Packed Horizontal Subtract and Saturate	Words
66 0F 38 07 /r	   PHSUBSW	xmm,xmm/m128		SSSE3				Packed Horizontal Subtract and Saturate	Words
   0F 38 08 /r	   PSIGNB	mm,mm/m64		SSSE3				Packed SIGN Bytes
66 0F 38 08 /r	   PSIGNB	xmm,xmm/m128		SSSE3				Packed SIGN Bytes
   0F 38 09 /r	   PSIGNW	mm,mm/m64		SSSE3				Packed SIGN Words
66 0F 38 09 /r	   PSIGNW	xmm,xmm/m128		SSSE3				Packed SIGN Words
   0F 38 0A /r	   PSIGND	mm,mm/m64		SSSE3				Packed SIGN Doublewords
66 0F 38 0A /r	   PSIGND	xmm,xmm/m128		SSSE3				Packed SIGN Doublewords
   0F 38 0B /r	   PMULHRSW	mm,mm/m64		SSSE3				Packed Multiply	High with Round	and Scale
66 0F 38 0B /r	   PMULHRSW	xmm,xmm/m128		SSSE3				Packed Multiply	High with Round	and Scale
66 0F 38 10 /r	   PBLENDVB	xmm,xmm/m128		SSE4.1				Variable Blend Packed Bytes
66 0F 38 14 /r	   BLENDVPS	xmm,xmm/m128		SSE4.1				Variable Blend Packed Single-Precision FP Values
66 0F 38 15 /r	   BLENDVPD	xmm,xmm/m128		SSE4.1				Variable Blend Packed Double-Precision FP Values
66 0F 38 17 /r	   PTEST	xmm,xmm/m128		SSE4.1				Packed Test
   0F 38 1C /r	   PABSB	mm,mm/m64		SSSE3				Packed Absolute	Value Bytes
66 0F 38 1C /r	   PABSB	xmm,xmm/m128		SSSE3				Packed Absolute	Value Bytes
   0F 38 1D /r	   PABSW	mm,mm/m64		SSSE3				Packed Absolute	Value Words
66 0F 38 1D /r	   PABSW	xmm,xmm/m128		SSSE3				Packed Absolute	Value Words
   0F 38 1E /r	   PABSD	mm,mm/m64		SSSE3				Packed Absolute	Value Doublewords
66 0F 38 1E /r	   PABSD	xmm,xmm/m128		SSSE3				Packed Absolute	Value Doublewords
66 0F 38 20 /r	   PMOVSXBW	xmm,xmm/m64		SSE4.1				Packed Move with Sign Extend Bytes to Words
66 0F 38 21 /r	   PMOVSXBD	xmm,xmm/m32		SSE4.1				Packed Move with Sign Extend Bytes to Doublewords
66 0F 38 22 /r	   PMOVSXBQ	xmm,xmm/m16		SSE4.1				Packed Move with Sign Extend Bytes to Quadwords
66 0F 38 23 /r	   PMOVSXWD	xmm,xmm/m64		SSE4.1				Packed Move with Sign Extend Words to Doublewords
66 0F 38 24 /r	   PMOVSXWQ	xmm,xmm/m32		SSE4.1				Packed Move with Sign Extend Words to Quadwords
66 0F 38 25 /r	   PMOVSXDQ	xmm,xmm/m64		SSE4.1				Packed Move with Sign Extend Doublewords to Quadwords
66 0F 38 28 /r	   PMULDQ	xmm,xmm/m128		SSE4.1				Packed Multiply	Signed Doubleword Integers
66 0F 38 29 /r	   PCMPEQQ	xmm,xmm/m128		SSE4.1				Packed Compare for Equal
66 0F 38 2A /r	   MOVNTDQA	xmm,m128		SSE4.1				Load Double Quadword Non-Temporal Aligned Hint
66 0F 38 2B /r	   PACKUSDW	xmm,xmm/m128		SSE4.1				Pack with Unsigned Saturation
66 0F 38 30 /r	   PMOVZXBW	xmm,xmm/m64		SSE4.1				Packed Move with Zero Extend Bytes to Words
66 0F 38 31 /r	   PMOVZXBD	xmm,xmm/m32		SSE4.1				Packed Move with Zero Extend Bytes to Doublewords
66 0F 38 32 /r	   PMOVZXBQ	xmm,xmm/m16		SSE4.1				Packed Move with Zero Extend Bytes to Quadwords
66 0F 38 33 /r	   PMOVZXWD	xmm,xmm/m64		SSE4.1				Packed Move with Zero Extend Words to Doublewords
66 0F 38 34 /r	   PMOVZXWQ	xmm,xmm/m32		SSE4.1				Packed Move with Zero Extend Words to Quadwords
66 0F 38 35 /r	   PMOVZXDQ	xmm,xmm/m64		SSE4.1				Packed Move with Zero Extend Doublewords to Quadwords
66 0F 38 37 /r	   PCMPGTQ	xmm,xmm/m128		SSE4.2				Packed Compare for Greater Than	Quadwords
66 0F 38 38 /r	   PMINSB	xmm,xmm/m128		SSE4.1				Packed Minimum Signed Integers Bytes
66 0F 38 39 /r	   PMINSD	xmm,xmm/m128		SSE4.1				Packed Minimum Signed Integers Doublewords
66 0F 38 3A /r	   PMINUW	xmm,xmm/m128		SSE4.1				Packed Minimum Unsigned	Integers Words
66 0F 38 3B /r	   PMINUD	xmm,xmm/m128		SSE4.1				Packed Minimum Unsigned	Integers Doublewords
66 0F 38 3C /r	   PMAXSB	xmm,xmm/m128		SSE4.1				Packed Maximum Signed Integers Bytes
66 0F 38 3D /r	   PMAXSD	xmm,xmm/m128		SSE4.1				Packed Maximum Signed Integers Doublewords
66 0F 38 3E /r	   PMAXUW	xmm,xmm/m128		SSE4.1				Packed Maximum Unsigned	Integers Words
66 0F 38 3F /r	   PMAXUD	xmm,xmm/m128		SSE4.1				Packed Maximum Unsigned	Integers Doublewords
66 0F 38 40 /r	   PMULLD	xmm,xmm/m128		SSE4.1				Packed Multiply	Signed Doubleword Integers and Store Low Result
66 0F 38 41 /r	   PHMINPOSUW	xmm,xmm/m128		SSE4.1				Packed Horizontal Word Minimum
66 0F 38 80 /r	   INVEPT	r32,m128		VMX				Invalidate Translations	Derived	from EPT
66 0F 38 81 /r	   INVVPID	r32,m128		VMX				Invalidate Translations	Based on VPID
66 0F 38 82 /r	   INVPCID	r32,m128		INVPCID				Invalidate Process-Context Identifier
   0F 38 F0 /r	   MOVBE	r16/32,m16/32		MOVBE				Move Data After	Swapping Bytes
F2 0F 38 F0 /r	   CRC32	r32,r/m8		SSE4.2				Accumulate CRC32 Value
   0F 38 F1 /r	   MOVBE	m16/32,r16/32		MOVBE				Move Data After	Swapping Bytes
F2 0F 38 F1 /r	   CRC32	r32,r/m16/32		SSE4.2				Accumulate CRC32 Value
66 0F 3A 08 /r ib  ROUNDPS	xmm,xmm/m128,i8		SSE4.1				Round Packed Single-Precision FP Values
66 0F 3A 09 /r ib  ROUNDPD	xmm,xmm/m128,i8		SSE4.1				Round Packed Double-Precision FP Values
66 0F 3A 0A /r ib  ROUNDSS	xmm,xmm/m32,i8		SSE4.1				Round Scalar Single Precision FP Values
66 0F 3A 0B /r ib  ROUNDSD	xmm,xmm/m64,i8		SSE4.1				Round Scalar Double Precision FP Values
66 0F 3A 0C /r ib  BLENDPS	xmm,xmm/m128,i8		SSE4.1				Blend Packed Single-Precision FP Values
66 0F 3A 0D /r ib  BLENDPD	xmm,xmm/m128,i8		SSE4.1				Blend Packed Double-Precision FP Values
66 0F 3A 0E /r ib  PBLENDW	xmm,xmm/m128,i8		SSE4.1				Blend Packed Words
   0F 3A 0F /r ib  PALIGNR	mm,mm/m64,i8		SSSE3				Packed Align Right
66 0F 3A 0F /r ib  PALIGNR	xmm,xmm/m128,i8		SSSE3				Packed Align Right
66 0F 3A 14 /r ib  PEXTRB	r32/m8,xmm,i8		SSE4.1				Packed Extract Bytes
66 0F 3A 15 /r ib  PEXTRW	r32/m16,xmm,i8		SSE4.1				Packed Extract Words
66 0F 3A 16 /r ib  PEXTRD	r/m32,xmm,i8		SSE4.1				Packed Extract Doublewords
66 0F 3A 17 /r ib  EXTRACTPS	r/m32,xmm,i8		SSE4.1				Extract	Packed Single-Precision	FP Value
66 0F 3A 20 /r ib  PINSRB	xmm,r32/m8,i8		SSE4.1				Packed Insert Bytes
66 0F 3A 21 /r ib  INSERTPS	xmm,r/m32,i8		SSE4.1				Insert Packed Single Precision FP Value
66 0F 3A 22 /r ib  PINSRD	xmm,r/m32,i8		SSE4.1				Packed Insert Doublewords
66 0F 3A 40 /r ib  DPPS		xmm,xmm/m128,i8		SSE4.1				Dot Product of Packed Single-Precision FP Values
66 0F 3A 41 /r ib  DPPD		xmm,xmm/m128,i8		SSE4.1				Dot Product of Packed Double-Precision FP Values
66 0F 3A 42 /r ib  MPSADBW	xmm,xmm/m128,i8		SSE4.1				Compute	Multiple Packed	Sums of	Absolute Difference
66 0F 3A 44 /r ib  PCLMULQDQ	xmm,xmm/m128,i8		PCLMULQDQ			Carry-Less Multiply Quadword
66 0F 3A 60 /r ib  PCMPESTRM	xmm,xmm/m128,i8		SSE4.2				Packed Compare Explicit	Length Strings,	Return Mask
66 0F 3A 61 /r ib  PCMPESTRI	xmm,xmm/m128,i8		SSE4.2				Packed Compare Explicit	Length Strings,	Return Index
66 0F 3A 62 /r ib  PCMPISTRM	xmm,xmm/m128,i8		SSE4.2				Packed Compare Implicit	Length Strings,	Return Mask
66 0F 3A 63 /r ib  PCMPISTRI	xmm,xmm/m128,i8		SSE4.2				Packed Compare Implicit	Length Strings,	Return Index

/n  opcode info	in reg field (0-7)
/r  register info in reg field
/s  segment register info in reg field (0=ES,1=CS,2=SS,3=DS,4=FS,5=GS)
/c  control register number in reg field
/d  debug register number in reg field
/t  test register number in reg	field
ib  immediate byte
iw  immediate word
id  immediate doubleword
rel relative displacement
ptr absolute pointer
off absolute offset
+i  floating-point stack index

16-bit instruction encoding:
opcode	mod-r/m	 disp  data
1-2	0-1	 0-2   0-2

16-bit mod-reg-r/m byte:
mod addressing mode
    00 indirect	with no	displacement unless r/m=110 then direct	16-bit displacement
    01 indirect	with 8-bit signed displacement
    10 indirect	with 16-bit displacement
    11 two registers: r/m=source,reg=dest
reg register or	additional opcode encoding info
    000	AL/AX
    001	CL/CX
    010	DL/DX
    011	BL/BX
    100	AH/SP
    101	CH/BP
    110	DH/SI
    111	BH/DI
r/m register/memory or source register
    000	[BX+SI]
    001	[BX+DI]
    010	[BP+SI]
    011	[BP+DI]
    100	[SI]
    101	[DI]
    110	[BP] or	16-bit displacement if mod=00
    111	[BX]

32-bit instruction encoding:
opcode	mod-r/m	 sib  disp  data
1-2	0-1	 0-1  0-4   0-4

32-bit mod-reg-r/m byte:
mod addressing mode
    00 indirect	with no	displacement unless r/m=110 then direct	32-bit displacement
    01 indirect	with 8-bit signed displacement
    10 indirect	with 32-bit displacement
    11 two registers: r/m=source,reg=dest
reg register or	additional opcode encoding info
    000	AL/AX/EAX
    001	CL/CX/ECX
    010	DL/DX/EDX
    011	BL/BX/EBX
    100	AH/SP/ESP
    101	CH/BP/EBP
    110	DH/SI/ESI
    111	BH/DI/EDI
r/m register/memory or source register
    000	[EAX]
    001	[ECX]
    010	[EDX]
    011	[EBX]
    100	SIB used
    101	[EBP] or 32-bit	displacement if	mod=00
    110	[ESI]
    111	[EDI]

32-bit scale index base	byte:
s scaling
  00 1
  01 2
  10 4
  11 8
i index	register
  000 [EAX*s]
  001 [ECX*s]
  010 [EDX*s]
  011 [EBX*s]
  100 no index
  101 [EBP*s]
  110 [ESI*s]
  111 [EDI*s]
b base register
  000 [EAX]
  001 [ECX]
  010 [EDX]
  011 [EBX]
  100 [ESP]
  101 [EBP] or 32-bit displacement if mod=00
  110 [ESI]
  111 [EDI]

Flags:
Bit 0 CF - carry flag
    1 reserved (1)
    2 PF - parity flag
    3 reserved (0)
    4 AF - auxiliary carry flag
    5 reserved (0)
    6 ZF - zero	flag
    7 SF - sign	flag
    8 TF - trap	flag
    9 IF - interrupt enable flag
   10 DF - direction flag
   11 OF - overflow flag
12-13 IOPL - I/O privilege level (286+)
   14 NT - nested task (286+)
   15 reserved (0)
   16 RF - resume flag (386+)
   17 VM - virtual 8086	mode (386+)
   18 AC - alignment check (486+)
   19 VIF - virtual interrupt flag (P5+)
   20 VIP - virtual interrupt pending (P5+)
   21 ID - ID flag (P5+	and later 486)
22-31 reserved (0)

FPU control word:
Bit 0 IM - invalid operation
    1 DM - denormalized	operand
    2 ZM - zero	divide
    3 OM - overflow
    4 UM - underflow
    5 PM - precision
  6-7 reserved
  8-9 PC - precision control (00=24 bits,01=reserved,10=53 bits,11=64 bits)
10-11 RC - rounding control (00=round to nearest,01=round down,10=round	up,11=truncate)
12-15 reserved

FPU status word:
Bit 0 IE - invalid operation
    1 DE - denormalized	operand
    2 ZE - zero	divide
    3 OE - overflow
    4 UE - underflow
    5 PE - precision
    6 SF - stack fault
    7 ES - error status
    8 C0 - condition code
    9 C1
   10 C2
11-13 TOP - stack top
   14 C3
   15 B	- busy

Interrupts:
00 divide error
01 debug / single-step
02 NMI
03 breakpoint
04 overflow (INTO)
05 bound range exceeded		186+
06 invalid opcode		186+
07 FPU not available		286+
08 double fault	(abort)		286+
09 FPU segment overrun		286/386	only
0A invalid TSS			286+
0B segment not present		286+
0C stack segment fault		286+
0D general protection fault	286+
0E page	fault			386+
0F reserved			386+
10 floating-point error		386+
11 alignment check		486+
12 machine check (abort)	P5+
13 SIMD	floating-point error	SSE

Segment	descriptor format:
Bit 0-15 segment limit 0-15
   16-39 base address 0-23
   40-43 type if code/data:
	 40 1=accessed		40 1=accessed
	 41 1=writable		41 1=readable
	 42 1=expand down	42 1=conforming
	 43 0=data		43 1=code
	 type if system:
	 0=reserved		     8=reserved
	 1=16-bit available TSS	     9=32-bit available	TSS
	 2=LDT			    10=reserved
	 3=16-bit busy TSS	    11=32-bit busy TSS
      44 segment descriptor type flag (0=system,1=code/data)
   45-46 descriptor privilege level
      47 segment present flag
   48-51 segment limit 16-19
      52 available for use by system software
      53 reserved (0)
      54 default/big flag
      55 granularity flag (0=byte,1=4KB)
   56-63 base address 24-31

Gate descriptor	format:
Bit 0-15 offset	0-15 (unused for task gates)
   16-31 segment selector
   32-36 parameter count (call gates only)
   37-39 reserved
   40-43 type:
	 4=16-bit call gate	    12=32-bit call gate
	 5=task	gate		    13=reserved
	 6=16-bit interrupt gate    14=32-bit interrupt	gate
	 7=16-bit trap gate	    15=32-bit trap gate
      44 segment descriptor type flag (0=system)
   45-46 descriptor privilege level
      47 segment present flag
   48-63 offset	16-31 (unused for task gates)

Modified flags reference:
AAA/AAS			OF=? SF=? ZF=? AF=* PF=? CF=*
AAD/AAM			OF=? SF=* ZF=* AF=? PF=* CF=?
ADC/ADD/CMP/SBB/SUB	OF=* SF=* ZF=* AF=* PF=* CF=*
AND/OR/TEST/XOR		OF=0 SF=* ZF=* AF=? PF=* CF=0
ARPL				  ZF=*
BOUND
BSF/BSR			OF=? SF=? ZF=* AF=? PF=? CF=?
BSWAP
BT/BTC/BTR/BTS		OF=? SF=?      AF=? PF=? CF=*
CALL
CBW/CDQ/CWD/CWDE
CLC						 CF=0
CLD						      DF=0
CLI							   IF=0
CLTS
CMC						 CF=*
CMOVcc
CMPSB/CMPSW/CMPSD	OF=* SF=* ZF=* AF=* PF=* CF=*
CMPXCHG			OF=* SF=* ZF=* AF=* PF=* CF=*
CMPXCHG8B			  ZF=*
COMISx/UCOMISx		OF=0 SF=0 ZF=* AF=0 PF=* CF=*
CPUID
DAA/DAS			OF=? SF=* ZF=* AF=* PF=* CF=*
DEC/INC			OF=* SF=* ZF=* AF=* PF=*
DIV/IDIV		OF=? SF=? ZF=? AF=? PF=? CF=?
ENTER
FCOMIx/FUCOMIx		OF=0 SF=0 ZF=* AF=0 PF=* CF=*
HLT
IN
INSB/INSW/INSD
INT/INTO						   IF=0	TF=0
INVD/WBINVD
INVLPG
IRET			OF=* SF=* ZF=* AF=* PF=* CF=* DF=* IF=*	TF=*
Jcc/JCXZ/JECXZ/JMP
LAHF
LAR/LSL				  ZF=*
LDS/LES/LFS/LGS/LSS
LEA
LEAVE
LGDT/LIDT/LLDT/LMSW/LTR
LOCK
LODSB/LODSW/LODSD
LOOP/LOOPE/LOOPNE
MOV
MOVSB/MOVSW/MOVSD
MOVSX/MOVZX
MUL/IMUL		OF=* SF=? ZF=? AF=? PF=? CF=*
NEG			OF=* SF=* ZF=* AF=* PF=* CF=*
NOP
NOT
OUT
OUTSB/OUTSW/OUTSD
POP/POPA
POPF			OF=* SF=* ZF=* AF=* PF=* CF=* DF=* IF=*	TF=*
PUSH/PUSHA
PUSHF
RCL/RCR/ROL/ROR		OF=*			 CF=*
RDMSR/RDTSC/WRMSR
RDPMC
REP/REPE/REPNE
RET/RETF
RSM			OF=* SF=* ZF=* AF=* PF=* CF=* DF=* IF=*	TF=*
SAHF			     SF=* ZF=* AF=* PF=* CF=*
SAL/SAR/SHL/SHR		OF=* SF=* ZF=* AF=? PF=* CF=*
SCASB/SCASW/SCASD	OF=* SF=* ZF=* AF=* PF=* CF=*
SETcc
SGDT/SIDT/SLDT/SMSW/STR
SHLD/SHRD		OF=* SF=* ZF=* AF=? PF=* CF=*
STC						 CF=1
STD						      DF=1
STI							   IF=1
STOSB/STOSW/STOSD
VERR/VERW			  ZF=*
WAIT
XADD			OF=* SF=* ZF=* AF=* PF=* CF=*
XCHG
XLAT
